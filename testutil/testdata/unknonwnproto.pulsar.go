// Code generated by Pulsar ü™ê. DO NOT EDIT.
// Pulsar version: (devel)
// source: unknonwnproto.proto

package testdata

import (
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	v1beta1 "github.com/cosmos/cosmos-sdk/testutil/testdata/cosmos/tx/v1beta1"
	proto "google.golang.org/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	io "io"
	math "math"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

var (
	// Interface guards to verify each message implements proto message interface
	_ protoreflect.Message = &Customer1{}
	_ protoreflect.Message = &Customer2{}
	_ protoreflect.Message = &Nested4A{}
	_ protoreflect.Message = &Nested3A{}
	_ protoreflect.Message = &Nested2A{}
	_ protoreflect.Message = &Nested1A{}
	_ protoreflect.Message = &Nested4B{}
	_ protoreflect.Message = &Nested3B{}
	_ protoreflect.Message = &Nested2B{}
	_ protoreflect.Message = &Nested1B{}
	_ protoreflect.Message = &Customer3{}
	_ protoreflect.Message = &TestVersion1{}
	_ protoreflect.Message = &TestVersion2{}
	_ protoreflect.Message = &TestVersion3{}
	_ protoreflect.Message = &TestVersion3LoneOneOfValue{}
	_ protoreflect.Message = &TestVersion3LoneNesting{}
	_ protoreflect.Message = &TestVersion4LoneNesting{}
	_ protoreflect.Message = &TestVersionFD1{}
	_ protoreflect.Message = &TestVersionFD1WithExtraAny{}
	_ protoreflect.Message = &AnyWithExtra{}
	_ protoreflect.Message = &TestUpdatedTxRaw{}
	_ protoreflect.Message = &TestUpdatedTxBody{}
	_ protoreflect.Message = &TestUpdatedAuthInfo{}
	_ protoreflect.Message = &TestRepeatedUints{}
)

type Customer2_City int32

const (
	Customer2_Laos       Customer2_City = 0
	Customer2_LosAngeles Customer2_City = 1
	Customer2_PaloAlto   Customer2_City = 2
	Customer2_Moscow     Customer2_City = 3
	Customer2_Nairobi    Customer2_City = 4
)

// Enum value maps for Customer2_City.
var (
	Customer2_City_name = map[int32]string{
		0: "Laos",
		1: "LosAngeles",
		2: "PaloAlto",
		3: "Moscow",
		4: "Nairobi",
	}
	Customer2_City_value = map[string]int32{
		"Laos":       0,
		"LosAngeles": 1,
		"PaloAlto":   2,
		"Moscow":     3,
		"Nairobi":    4,
	}
)

func (x Customer2_City) Enum() *Customer2_City {
	p := new(Customer2_City)
	*p = x
	return p
}

func (x Customer2_City) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Customer2_City) Descriptor() protoreflect.EnumDescriptor {
	return file_unknonwnproto_proto_enumTypes[0].Descriptor()
}

func (Customer2_City) Type() protoreflect.EnumType {
	return &file_unknonwnproto_proto_enumTypes[0]
}

func (x Customer2_City) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Customer2_City.Descriptor instead.
func (Customer2_City) EnumDescriptor() ([]byte, []int) {
	return file_unknonwnproto_proto_rawDescGZIP(), []int{1, 0}
}

type Customer1 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id              int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name            string  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	SubscriptionFee float32 `protobuf:"fixed32,3,opt,name=subscription_fee,json=subscriptionFee,proto3" json:"subscription_fee,omitempty"`
	Payment         string  `protobuf:"bytes,7,opt,name=payment,proto3" json:"payment,omitempty"`
}

func (x *Customer1) Reset() {
	*x = Customer1{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Customer1) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Customer1) ProtoMessage() {}

func (x *Customer1) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Customer1) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Customer1) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Customer1) GetSubscriptionFee() float32 {
	if x != nil {
		return x.SubscriptionFee
	}
	return 0
}

func (x *Customer1) GetPayment() string {
	if x != nil {
		return x.Payment
	}
	return ""
}

// returns the fast methods for the message
func (x Customer1) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*Customer1)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("Customer1 does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*Customer1)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("Customer1 does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x Customer1) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x Customer1) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x Customer1) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x Customer1) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x Customer1) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x Customer1) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x Customer1) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *Customer1) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt32(x.Id)
	case "name":
		return protoreflect.ValueOfString(x.Name)
	case "subscription_fee":
		return protoreflect.ValueOfFloat32(x.SubscriptionFee)
	case "payment":
		return protoreflect.ValueOfString(x.Payment)
	default:
		panic(fmt.Errorf("message testdata.Customer1 does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x Customer1) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x Customer1) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x Customer1) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x Customer1) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x Customer1) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x Customer1) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x Customer1) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x Customer1) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type Customer2 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id            int32          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Industry      int32          `protobuf:"varint,2,opt,name=industry,proto3" json:"industry,omitempty"`
	Name          string         `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Fewer         float32        `protobuf:"fixed32,4,opt,name=fewer,proto3" json:"fewer,omitempty"`
	Reserved      int64          `protobuf:"varint,1047,opt,name=reserved,proto3" json:"reserved,omitempty"`
	City          Customer2_City `protobuf:"varint,6,opt,name=city,proto3,enum=testdata.Customer2_City" json:"city,omitempty"`
	Miscellaneous *anypb.Any     `protobuf:"bytes,10,opt,name=miscellaneous,proto3" json:"miscellaneous,omitempty"`
}

func (x *Customer2) Reset() {
	*x = Customer2{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Customer2) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Customer2) ProtoMessage() {}

func (x *Customer2) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Customer2) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Customer2) GetIndustry() int32 {
	if x != nil {
		return x.Industry
	}
	return 0
}

func (x *Customer2) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Customer2) GetFewer() float32 {
	if x != nil {
		return x.Fewer
	}
	return 0
}

func (x *Customer2) GetReserved() int64 {
	if x != nil {
		return x.Reserved
	}
	return 0
}

func (x *Customer2) GetCity() Customer2_City {
	if x != nil {
		return x.City
	}
	return Customer2_Laos
}

func (x *Customer2) GetMiscellaneous() *anypb.Any {
	if x != nil {
		return x.Miscellaneous
	}
	return nil
}

// returns the fast methods for the message
func (x Customer2) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*Customer2)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("Customer2 does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*Customer2)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("Customer2 does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x Customer2) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x Customer2) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x Customer2) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x Customer2) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x Customer2) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x Customer2) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x Customer2) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *Customer2) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt32(x.Id)
	case "industry":
		return protoreflect.ValueOfInt32(x.Industry)
	case "name":
		return protoreflect.ValueOfString(x.Name)
	case "fewer":
		return protoreflect.ValueOfFloat32(x.Fewer)
	case "reserved":
		return protoreflect.ValueOfInt64(x.Reserved)
	case "city":
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.City))
	case "miscellaneous":
		return protoreflect.ValueOfMessage(x.Miscellaneous)
	default:
		panic(fmt.Errorf("message testdata.Customer2 does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x Customer2) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x Customer2) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x Customer2) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x Customer2) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x Customer2) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x Customer2) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x Customer2) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x Customer2) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type Nested4A struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id   int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *Nested4A) Reset() {
	*x = Nested4A{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Nested4A) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Nested4A) ProtoMessage() {}

func (x *Nested4A) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Nested4A) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Nested4A) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// returns the fast methods for the message
func (x Nested4A) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*Nested4A)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("Nested4A does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*Nested4A)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("Nested4A does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x Nested4A) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x Nested4A) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x Nested4A) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x Nested4A) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x Nested4A) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x Nested4A) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x Nested4A) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *Nested4A) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt32(x.Id)
	case "name":
		return protoreflect.ValueOfString(x.Name)
	default:
		panic(fmt.Errorf("message testdata.Nested4A does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x Nested4A) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x Nested4A) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x Nested4A) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x Nested4A) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x Nested4A) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x Nested4A) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x Nested4A) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x Nested4A) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type Nested3A struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id    int32               `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name  string              `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	A4    []*Nested4A         `protobuf:"bytes,4,rep,name=a4,proto3" json:"a4,omitempty"`
	Index map[int64]*Nested4A `protobuf:"bytes,5,rep,name=index,proto3" json:"index,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *Nested3A) Reset() {
	*x = Nested3A{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Nested3A) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Nested3A) ProtoMessage() {}

func (x *Nested3A) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Nested3A) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Nested3A) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Nested3A) GetA4() []*Nested4A {
	if x != nil {
		return x.A4
	}
	return nil
}

func (x *Nested3A) GetIndex() map[int64]*Nested4A {
	if x != nil {
		return x.Index
	}
	return nil
}

// returns the fast methods for the message
func (x Nested3A) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*Nested3A)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("Nested3A does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*Nested3A)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("Nested3A does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x Nested3A) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x Nested3A) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x Nested3A) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x Nested3A) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x Nested3A) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x Nested3A) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x Nested3A) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _Nested3A_4_list struct {
	list []*Nested4A
}

var _ protoreflect.List = (*_Nested3A_4_list)(nil)

func (x *_Nested3A_4_list) Len() int {
	return len(x.list)
}

func (x *_Nested3A_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_Nested3A_4_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*Nested4A)
	x.list[i] = concreteValue
}

func (x *_Nested3A_4_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*Nested4A)
	x.list = append(x.list, concreteValue)
}

func (x *_Nested3A_4_list) AppendMutable() protoreflect.Value {
	v := new(Nested4A)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Nested3A_4_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_Nested3A_4_list) NewElement() protoreflect.Value {
	v := new(Nested4A)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Nested3A_4_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *Nested3A) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt32(x.Id)
	case "name":
		return protoreflect.ValueOfString(x.Name)
	case "a4":
	case "index":
	default:
		panic(fmt.Errorf("message testdata.Nested3A does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x Nested3A) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x Nested3A) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x Nested3A) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x Nested3A) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x Nested3A) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x Nested3A) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x Nested3A) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x Nested3A) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type Nested2A struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id     int32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name   string    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Nested *Nested3A `protobuf:"bytes,3,opt,name=nested,proto3" json:"nested,omitempty"`
}

func (x *Nested2A) Reset() {
	*x = Nested2A{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Nested2A) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Nested2A) ProtoMessage() {}

func (x *Nested2A) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Nested2A) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Nested2A) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Nested2A) GetNested() *Nested3A {
	if x != nil {
		return x.Nested
	}
	return nil
}

// returns the fast methods for the message
func (x Nested2A) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*Nested2A)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("Nested2A does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*Nested2A)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("Nested2A does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x Nested2A) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x Nested2A) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x Nested2A) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x Nested2A) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x Nested2A) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x Nested2A) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x Nested2A) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *Nested2A) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt32(x.Id)
	case "name":
		return protoreflect.ValueOfString(x.Name)
	case "nested":
		return protoreflect.ValueOfMessage(x.Nested)
	default:
		panic(fmt.Errorf("message testdata.Nested2A does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x Nested2A) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x Nested2A) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x Nested2A) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x Nested2A) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x Nested2A) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x Nested2A) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x Nested2A) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x Nested2A) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type Nested1A struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id     int32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Nested *Nested2A `protobuf:"bytes,2,opt,name=nested,proto3" json:"nested,omitempty"`
}

func (x *Nested1A) Reset() {
	*x = Nested1A{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Nested1A) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Nested1A) ProtoMessage() {}

func (x *Nested1A) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Nested1A) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Nested1A) GetNested() *Nested2A {
	if x != nil {
		return x.Nested
	}
	return nil
}

// returns the fast methods for the message
func (x Nested1A) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*Nested1A)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("Nested1A does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*Nested1A)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("Nested1A does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x Nested1A) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x Nested1A) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x Nested1A) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x Nested1A) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x Nested1A) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x Nested1A) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x Nested1A) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *Nested1A) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt32(x.Id)
	case "nested":
		return protoreflect.ValueOfMessage(x.Nested)
	default:
		panic(fmt.Errorf("message testdata.Nested1A does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x Nested1A) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x Nested1A) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x Nested1A) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x Nested1A) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x Nested1A) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x Nested1A) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x Nested1A) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x Nested1A) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type Nested4B struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id   int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Age  int32  `protobuf:"varint,2,opt,name=age,proto3" json:"age,omitempty"`
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *Nested4B) Reset() {
	*x = Nested4B{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Nested4B) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Nested4B) ProtoMessage() {}

func (x *Nested4B) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Nested4B) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Nested4B) GetAge() int32 {
	if x != nil {
		return x.Age
	}
	return 0
}

func (x *Nested4B) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// returns the fast methods for the message
func (x Nested4B) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*Nested4B)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("Nested4B does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*Nested4B)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("Nested4B does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x Nested4B) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x Nested4B) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x Nested4B) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x Nested4B) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x Nested4B) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x Nested4B) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x Nested4B) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *Nested4B) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt32(x.Id)
	case "age":
		return protoreflect.ValueOfInt32(x.Age)
	case "name":
		return protoreflect.ValueOfString(x.Name)
	default:
		panic(fmt.Errorf("message testdata.Nested4B does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x Nested4B) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x Nested4B) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x Nested4B) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x Nested4B) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x Nested4B) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x Nested4B) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x Nested4B) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x Nested4B) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type Nested3B struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id   int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Age  int32       `protobuf:"varint,2,opt,name=age,proto3" json:"age,omitempty"`
	Name string      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	B4   []*Nested4B `protobuf:"bytes,4,rep,name=b4,proto3" json:"b4,omitempty"`
}

func (x *Nested3B) Reset() {
	*x = Nested3B{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Nested3B) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Nested3B) ProtoMessage() {}

func (x *Nested3B) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Nested3B) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Nested3B) GetAge() int32 {
	if x != nil {
		return x.Age
	}
	return 0
}

func (x *Nested3B) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Nested3B) GetB4() []*Nested4B {
	if x != nil {
		return x.B4
	}
	return nil
}

// returns the fast methods for the message
func (x Nested3B) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*Nested3B)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("Nested3B does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*Nested3B)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("Nested3B does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x Nested3B) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x Nested3B) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x Nested3B) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x Nested3B) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x Nested3B) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x Nested3B) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x Nested3B) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _Nested3B_4_list struct {
	list []*Nested4B
}

var _ protoreflect.List = (*_Nested3B_4_list)(nil)

func (x *_Nested3B_4_list) Len() int {
	return len(x.list)
}

func (x *_Nested3B_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_Nested3B_4_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*Nested4B)
	x.list[i] = concreteValue
}

func (x *_Nested3B_4_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*Nested4B)
	x.list = append(x.list, concreteValue)
}

func (x *_Nested3B_4_list) AppendMutable() protoreflect.Value {
	v := new(Nested4B)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Nested3B_4_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_Nested3B_4_list) NewElement() protoreflect.Value {
	v := new(Nested4B)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Nested3B_4_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *Nested3B) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt32(x.Id)
	case "age":
		return protoreflect.ValueOfInt32(x.Age)
	case "name":
		return protoreflect.ValueOfString(x.Name)
	case "b4":
	default:
		panic(fmt.Errorf("message testdata.Nested3B does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x Nested3B) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x Nested3B) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x Nested3B) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x Nested3B) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x Nested3B) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x Nested3B) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x Nested3B) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x Nested3B) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type Nested2B struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id     int32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Fee    float64   `protobuf:"fixed64,2,opt,name=fee,proto3" json:"fee,omitempty"`
	Nested *Nested3B `protobuf:"bytes,3,opt,name=nested,proto3" json:"nested,omitempty"`
	Route  string    `protobuf:"bytes,4,opt,name=route,proto3" json:"route,omitempty"`
}

func (x *Nested2B) Reset() {
	*x = Nested2B{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Nested2B) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Nested2B) ProtoMessage() {}

func (x *Nested2B) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Nested2B) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Nested2B) GetFee() float64 {
	if x != nil {
		return x.Fee
	}
	return 0
}

func (x *Nested2B) GetNested() *Nested3B {
	if x != nil {
		return x.Nested
	}
	return nil
}

func (x *Nested2B) GetRoute() string {
	if x != nil {
		return x.Route
	}
	return ""
}

// returns the fast methods for the message
func (x Nested2B) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*Nested2B)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("Nested2B does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*Nested2B)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("Nested2B does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x Nested2B) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x Nested2B) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x Nested2B) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x Nested2B) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x Nested2B) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x Nested2B) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x Nested2B) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *Nested2B) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt32(x.Id)
	case "fee":
		return protoreflect.ValueOfFloat64(x.Fee)
	case "nested":
		return protoreflect.ValueOfMessage(x.Nested)
	case "route":
		return protoreflect.ValueOfString(x.Route)
	default:
		panic(fmt.Errorf("message testdata.Nested2B does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x Nested2B) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x Nested2B) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x Nested2B) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x Nested2B) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x Nested2B) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x Nested2B) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x Nested2B) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x Nested2B) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type Nested1B struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id     int32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Nested *Nested2B `protobuf:"bytes,2,opt,name=nested,proto3" json:"nested,omitempty"`
	Age    int32     `protobuf:"varint,3,opt,name=age,proto3" json:"age,omitempty"`
}

func (x *Nested1B) Reset() {
	*x = Nested1B{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Nested1B) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Nested1B) ProtoMessage() {}

func (x *Nested1B) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Nested1B) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Nested1B) GetNested() *Nested2B {
	if x != nil {
		return x.Nested
	}
	return nil
}

func (x *Nested1B) GetAge() int32 {
	if x != nil {
		return x.Age
	}
	return 0
}

// returns the fast methods for the message
func (x Nested1B) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*Nested1B)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("Nested1B does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*Nested1B)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("Nested1B does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x Nested1B) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x Nested1B) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x Nested1B) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x Nested1B) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x Nested1B) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x Nested1B) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x Nested1B) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *Nested1B) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt32(x.Id)
	case "nested":
		return protoreflect.ValueOfMessage(x.Nested)
	case "age":
		return protoreflect.ValueOfInt32(x.Age)
	default:
		panic(fmt.Errorf("message testdata.Nested1B does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x Nested1B) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x Nested1B) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x Nested1B) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x Nested1B) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x Nested1B) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x Nested1B) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x Nested1B) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x Nested1B) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type Customer3 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id          int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name        string  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Sf          float32 `protobuf:"fixed32,3,opt,name=sf,proto3" json:"sf,omitempty"`
	Surcharge   float32 `protobuf:"fixed32,4,opt,name=surcharge,proto3" json:"surcharge,omitempty"`
	Destination string  `protobuf:"bytes,5,opt,name=destination,proto3" json:"destination,omitempty"`
	// Types that are assignable to Payment:
	//	*Customer3_CreditCardNo
	//	*Customer3_ChequeNo
	Payment  isCustomer3_Payment `protobuf_oneof:"payment"`
	Original *Customer1          `protobuf:"bytes,9,opt,name=original,proto3" json:"original,omitempty"`
}

func (x *Customer3) Reset() {
	*x = Customer3{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Customer3) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Customer3) ProtoMessage() {}

func (x *Customer3) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Customer3) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Customer3) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Customer3) GetSf() float32 {
	if x != nil {
		return x.Sf
	}
	return 0
}

func (x *Customer3) GetSurcharge() float32 {
	if x != nil {
		return x.Surcharge
	}
	return 0
}

func (x *Customer3) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (m *Customer3) GetPayment() isCustomer3_Payment {
	if m != nil {
		return m.Payment
	}
	return nil
}

func (x *Customer3) GetCreditCardNo() string {
	if x, ok := x.GetPayment().(*Customer3_CreditCardNo); ok {
		return x.CreditCardNo
	}
	return ""
}

func (x *Customer3) GetChequeNo() string {
	if x, ok := x.GetPayment().(*Customer3_ChequeNo); ok {
		return x.ChequeNo
	}
	return ""
}

func (x *Customer3) GetOriginal() *Customer1 {
	if x != nil {
		return x.Original
	}
	return nil
}

type isCustomer3_Payment interface {
	isCustomer3_Payment()
}

type Customer3_CreditCardNo struct {
	CreditCardNo string `protobuf:"bytes,7,opt,name=credit_card_no,json=creditCardNo,proto3,oneof"`
}

type Customer3_ChequeNo struct {
	ChequeNo string `protobuf:"bytes,8,opt,name=cheque_no,json=chequeNo,proto3,oneof"`
}

func (*Customer3_CreditCardNo) isCustomer3_Payment() {}

func (*Customer3_ChequeNo) isCustomer3_Payment() {}

// returns the fast methods for the message
func (x Customer3) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*Customer3)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("Customer3 does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*Customer3)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("Customer3 does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x Customer3) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x Customer3) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x Customer3) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x Customer3) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x Customer3) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x Customer3) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x Customer3) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *Customer3) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt32(x.Id)
	case "name":
		return protoreflect.ValueOfString(x.Name)
	case "sf":
		return protoreflect.ValueOfFloat32(x.Sf)
	case "surcharge":
		return protoreflect.ValueOfFloat32(x.Surcharge)
	case "destination":
		return protoreflect.ValueOfString(x.Destination)
	case "credit_card_no":
		return protoreflect.ValueOfString(x.GetCreditCardNo())
	case "cheque_no":
		return protoreflect.ValueOfString(x.GetChequeNo())
	case "original":
		return protoreflect.ValueOfMessage(x.Original)
	default:
		panic(fmt.Errorf("message testdata.Customer3 does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x Customer3) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x Customer3) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x Customer3) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x Customer3) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x Customer3) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x Customer3) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x Customer3) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x Customer3) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion1 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	X int64           `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	A *TestVersion1   `protobuf:"bytes,2,opt,name=a,proto3" json:"a,omitempty"`
	B *TestVersion1   `protobuf:"bytes,3,opt,name=b,proto3" json:"b,omitempty"`
	C []*TestVersion1 `protobuf:"bytes,4,rep,name=c,proto3" json:"c,omitempty"`
	D []*TestVersion1 `protobuf:"bytes,5,rep,name=d,proto3" json:"d,omitempty"`
	// Types that are assignable to Sum:
	//	*TestVersion1_E
	//	*TestVersion1_F
	Sum isTestVersion1_Sum `protobuf_oneof:"sum"`
	G   *anypb.Any         `protobuf:"bytes,8,opt,name=g,proto3" json:"g,omitempty"`
	H   []*TestVersion1    `protobuf:"bytes,9,rep,name=h,proto3" json:"h,omitempty"`
	K   *Customer1         `protobuf:"bytes,12,opt,name=k,proto3" json:"k,omitempty"`
}

func (x *TestVersion1) Reset() {
	*x = TestVersion1{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion1) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion1) ProtoMessage() {}

func (x *TestVersion1) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion1) GetX() int64 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *TestVersion1) GetA() *TestVersion1 {
	if x != nil {
		return x.A
	}
	return nil
}

func (x *TestVersion1) GetB() *TestVersion1 {
	if x != nil {
		return x.B
	}
	return nil
}

func (x *TestVersion1) GetC() []*TestVersion1 {
	if x != nil {
		return x.C
	}
	return nil
}

func (x *TestVersion1) GetD() []*TestVersion1 {
	if x != nil {
		return x.D
	}
	return nil
}

func (m *TestVersion1) GetSum() isTestVersion1_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (x *TestVersion1) GetE() int32 {
	if x, ok := x.GetSum().(*TestVersion1_E); ok {
		return x.E
	}
	return 0
}

func (x *TestVersion1) GetF() *TestVersion1 {
	if x, ok := x.GetSum().(*TestVersion1_F); ok {
		return x.F
	}
	return nil
}

func (x *TestVersion1) GetG() *anypb.Any {
	if x != nil {
		return x.G
	}
	return nil
}

func (x *TestVersion1) GetH() []*TestVersion1 {
	if x != nil {
		return x.H
	}
	return nil
}

func (x *TestVersion1) GetK() *Customer1 {
	if x != nil {
		return x.K
	}
	return nil
}

type isTestVersion1_Sum interface {
	isTestVersion1_Sum()
}

type TestVersion1_E struct {
	E int32 `protobuf:"varint,6,opt,name=e,proto3,oneof"`
}

type TestVersion1_F struct {
	F *TestVersion1 `protobuf:"bytes,7,opt,name=f,proto3,oneof"`
}

func (*TestVersion1_E) isTestVersion1_Sum() {}

func (*TestVersion1_F) isTestVersion1_Sum() {}

// returns the fast methods for the message
func (x TestVersion1) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion1)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion1 does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion1)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion1 does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion1) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion1) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion1) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion1) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion1) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion1) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion1) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _TestVersion1_4_list struct {
	list []*TestVersion1
}

var _ protoreflect.List = (*_TestVersion1_4_list)(nil)

func (x *_TestVersion1_4_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion1_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion1_4_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list[i] = concreteValue
}

func (x *_TestVersion1_4_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion1_4_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion1_4_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion1_4_list) NewElement() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion1_4_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestVersion1_5_list struct {
	list []*TestVersion1
}

var _ protoreflect.List = (*_TestVersion1_5_list)(nil)

func (x *_TestVersion1_5_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion1_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion1_5_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list[i] = concreteValue
}

func (x *_TestVersion1_5_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion1_5_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion1_5_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion1_5_list) NewElement() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion1_5_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestVersion1_9_list struct {
	list []*TestVersion1
}

var _ protoreflect.List = (*_TestVersion1_9_list)(nil)

func (x *_TestVersion1_9_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion1_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion1_9_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list[i] = concreteValue
}

func (x *_TestVersion1_9_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion1_9_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion1_9_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion1_9_list) NewElement() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion1_9_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion1) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "x":
		return protoreflect.ValueOfInt64(x.X)
	case "a":
		return protoreflect.ValueOfMessage(x.A)
	case "b":
		return protoreflect.ValueOfMessage(x.B)
	case "c":
	case "d":
	case "e":
		return protoreflect.ValueOfInt32(x.GetE())
	case "f":
		return protoreflect.ValueOfMessage(x.GetF())
	case "g":
		return protoreflect.ValueOfMessage(x.G)
	case "h":
	case "k":
		return protoreflect.ValueOfMessage(x.K)
	default:
		panic(fmt.Errorf("message testdata.TestVersion1 does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion1) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion1) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion1) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion1) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion1) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion1) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion1) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion1) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion2 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	X int64           `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	A *TestVersion2   `protobuf:"bytes,2,opt,name=a,proto3" json:"a,omitempty"`
	B *TestVersion2   `protobuf:"bytes,3,opt,name=b,proto3" json:"b,omitempty"`
	C []*TestVersion2 `protobuf:"bytes,4,rep,name=c,proto3" json:"c,omitempty"`
	D []*TestVersion2 `protobuf:"bytes,5,rep,name=d,proto3" json:"d,omitempty"`
	// Types that are assignable to Sum:
	//	*TestVersion2_E
	//	*TestVersion2_F
	Sum      isTestVersion2_Sum `protobuf_oneof:"sum"`
	G        *anypb.Any         `protobuf:"bytes,8,opt,name=g,proto3" json:"g,omitempty"`
	H        []*TestVersion1    `protobuf:"bytes,9,rep,name=h,proto3" json:"h,omitempty"`
	K        *Customer1         `protobuf:"bytes,12,opt,name=k,proto3" json:"k,omitempty"`
	NewField uint64             `protobuf:"varint,25,opt,name=new_field,json=newField,proto3" json:"new_field,omitempty"`
}

func (x *TestVersion2) Reset() {
	*x = TestVersion2{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion2) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion2) ProtoMessage() {}

func (x *TestVersion2) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion2) GetX() int64 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *TestVersion2) GetA() *TestVersion2 {
	if x != nil {
		return x.A
	}
	return nil
}

func (x *TestVersion2) GetB() *TestVersion2 {
	if x != nil {
		return x.B
	}
	return nil
}

func (x *TestVersion2) GetC() []*TestVersion2 {
	if x != nil {
		return x.C
	}
	return nil
}

func (x *TestVersion2) GetD() []*TestVersion2 {
	if x != nil {
		return x.D
	}
	return nil
}

func (m *TestVersion2) GetSum() isTestVersion2_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (x *TestVersion2) GetE() int32 {
	if x, ok := x.GetSum().(*TestVersion2_E); ok {
		return x.E
	}
	return 0
}

func (x *TestVersion2) GetF() *TestVersion2 {
	if x, ok := x.GetSum().(*TestVersion2_F); ok {
		return x.F
	}
	return nil
}

func (x *TestVersion2) GetG() *anypb.Any {
	if x != nil {
		return x.G
	}
	return nil
}

func (x *TestVersion2) GetH() []*TestVersion1 {
	if x != nil {
		return x.H
	}
	return nil
}

func (x *TestVersion2) GetK() *Customer1 {
	if x != nil {
		return x.K
	}
	return nil
}

func (x *TestVersion2) GetNewField() uint64 {
	if x != nil {
		return x.NewField
	}
	return 0
}

type isTestVersion2_Sum interface {
	isTestVersion2_Sum()
}

type TestVersion2_E struct {
	E int32 `protobuf:"varint,6,opt,name=e,proto3,oneof"`
}

type TestVersion2_F struct {
	F *TestVersion2 `protobuf:"bytes,7,opt,name=f,proto3,oneof"`
}

func (*TestVersion2_E) isTestVersion2_Sum() {}

func (*TestVersion2_F) isTestVersion2_Sum() {}

// returns the fast methods for the message
func (x TestVersion2) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion2)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion2 does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion2)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion2 does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion2) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion2) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion2) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion2) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion2) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion2) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion2) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _TestVersion2_4_list struct {
	list []*TestVersion2
}

var _ protoreflect.List = (*_TestVersion2_4_list)(nil)

func (x *_TestVersion2_4_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion2_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion2_4_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion2)
	x.list[i] = concreteValue
}

func (x *_TestVersion2_4_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion2)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion2_4_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion2)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion2_4_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion2_4_list) NewElement() protoreflect.Value {
	v := new(TestVersion2)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion2_4_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestVersion2_5_list struct {
	list []*TestVersion2
}

var _ protoreflect.List = (*_TestVersion2_5_list)(nil)

func (x *_TestVersion2_5_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion2_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion2_5_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion2)
	x.list[i] = concreteValue
}

func (x *_TestVersion2_5_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion2)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion2_5_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion2)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion2_5_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion2_5_list) NewElement() protoreflect.Value {
	v := new(TestVersion2)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion2_5_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestVersion2_9_list struct {
	list []*TestVersion1
}

var _ protoreflect.List = (*_TestVersion2_9_list)(nil)

func (x *_TestVersion2_9_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion2_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion2_9_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list[i] = concreteValue
}

func (x *_TestVersion2_9_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion2_9_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion2_9_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion2_9_list) NewElement() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion2_9_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion2) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "x":
		return protoreflect.ValueOfInt64(x.X)
	case "a":
		return protoreflect.ValueOfMessage(x.A)
	case "b":
		return protoreflect.ValueOfMessage(x.B)
	case "c":
	case "d":
	case "e":
		return protoreflect.ValueOfInt32(x.GetE())
	case "f":
		return protoreflect.ValueOfMessage(x.GetF())
	case "g":
		return protoreflect.ValueOfMessage(x.G)
	case "h":
	case "k":
		return protoreflect.ValueOfMessage(x.K)
	case "new_field":
		return protoreflect.ValueOfUint64(x.NewField)
	default:
		panic(fmt.Errorf("message testdata.TestVersion2 does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion2) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion2) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion2) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion2) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion2) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion2) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion2) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion2) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion3 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	X int64           `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	A *TestVersion3   `protobuf:"bytes,2,opt,name=a,proto3" json:"a,omitempty"`
	B *TestVersion3   `protobuf:"bytes,3,opt,name=b,proto3" json:"b,omitempty"`
	C []*TestVersion3 `protobuf:"bytes,4,rep,name=c,proto3" json:"c,omitempty"`
	D []*TestVersion3 `protobuf:"bytes,5,rep,name=d,proto3" json:"d,omitempty"`
	// Types that are assignable to Sum:
	//	*TestVersion3_E
	//	*TestVersion3_F
	Sum              isTestVersion3_Sum `protobuf_oneof:"sum"`
	G                *anypb.Any         `protobuf:"bytes,8,opt,name=g,proto3" json:"g,omitempty"`
	H                []*TestVersion1    `protobuf:"bytes,9,rep,name=h,proto3" json:"h,omitempty"`
	K                *Customer1         `protobuf:"bytes,12,opt,name=k,proto3" json:"k,omitempty"`
	NonCriticalField string             `protobuf:"bytes,1031,opt,name=non_critical_field,json=nonCriticalField,proto3" json:"non_critical_field,omitempty"`
}

func (x *TestVersion3) Reset() {
	*x = TestVersion3{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion3) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion3) ProtoMessage() {}

func (x *TestVersion3) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion3) GetX() int64 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *TestVersion3) GetA() *TestVersion3 {
	if x != nil {
		return x.A
	}
	return nil
}

func (x *TestVersion3) GetB() *TestVersion3 {
	if x != nil {
		return x.B
	}
	return nil
}

func (x *TestVersion3) GetC() []*TestVersion3 {
	if x != nil {
		return x.C
	}
	return nil
}

func (x *TestVersion3) GetD() []*TestVersion3 {
	if x != nil {
		return x.D
	}
	return nil
}

func (m *TestVersion3) GetSum() isTestVersion3_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (x *TestVersion3) GetE() int32 {
	if x, ok := x.GetSum().(*TestVersion3_E); ok {
		return x.E
	}
	return 0
}

func (x *TestVersion3) GetF() *TestVersion3 {
	if x, ok := x.GetSum().(*TestVersion3_F); ok {
		return x.F
	}
	return nil
}

func (x *TestVersion3) GetG() *anypb.Any {
	if x != nil {
		return x.G
	}
	return nil
}

func (x *TestVersion3) GetH() []*TestVersion1 {
	if x != nil {
		return x.H
	}
	return nil
}

func (x *TestVersion3) GetK() *Customer1 {
	if x != nil {
		return x.K
	}
	return nil
}

func (x *TestVersion3) GetNonCriticalField() string {
	if x != nil {
		return x.NonCriticalField
	}
	return ""
}

type isTestVersion3_Sum interface {
	isTestVersion3_Sum()
}

type TestVersion3_E struct {
	E int32 `protobuf:"varint,6,opt,name=e,proto3,oneof"`
}

type TestVersion3_F struct {
	F *TestVersion3 `protobuf:"bytes,7,opt,name=f,proto3,oneof"`
}

func (*TestVersion3_E) isTestVersion3_Sum() {}

func (*TestVersion3_F) isTestVersion3_Sum() {}

// returns the fast methods for the message
func (x TestVersion3) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion3 does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion3 does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion3) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion3) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion3) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion3) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion3) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion3) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion3) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _TestVersion3_4_list struct {
	list []*TestVersion3
}

var _ protoreflect.List = (*_TestVersion3_4_list)(nil)

func (x *_TestVersion3_4_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion3_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion3_4_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list[i] = concreteValue
}

func (x *_TestVersion3_4_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion3_4_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3_4_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion3_4_list) NewElement() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3_4_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestVersion3_5_list struct {
	list []*TestVersion3
}

var _ protoreflect.List = (*_TestVersion3_5_list)(nil)

func (x *_TestVersion3_5_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion3_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion3_5_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list[i] = concreteValue
}

func (x *_TestVersion3_5_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion3_5_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3_5_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion3_5_list) NewElement() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3_5_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestVersion3_9_list struct {
	list []*TestVersion1
}

var _ protoreflect.List = (*_TestVersion3_9_list)(nil)

func (x *_TestVersion3_9_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion3_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion3_9_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list[i] = concreteValue
}

func (x *_TestVersion3_9_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion3_9_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3_9_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion3_9_list) NewElement() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3_9_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion3) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "x":
		return protoreflect.ValueOfInt64(x.X)
	case "a":
		return protoreflect.ValueOfMessage(x.A)
	case "b":
		return protoreflect.ValueOfMessage(x.B)
	case "c":
	case "d":
	case "e":
		return protoreflect.ValueOfInt32(x.GetE())
	case "f":
		return protoreflect.ValueOfMessage(x.GetF())
	case "g":
		return protoreflect.ValueOfMessage(x.G)
	case "h":
	case "k":
		return protoreflect.ValueOfMessage(x.K)
	case "non_critical_field":
		return protoreflect.ValueOfString(x.NonCriticalField)
	default:
		panic(fmt.Errorf("message testdata.TestVersion3 does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion3) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion3) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion3) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion3) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion3) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion3) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion3) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion3) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion3LoneOneOfValue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	X int64           `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	A *TestVersion3   `protobuf:"bytes,2,opt,name=a,proto3" json:"a,omitempty"`
	B *TestVersion3   `protobuf:"bytes,3,opt,name=b,proto3" json:"b,omitempty"`
	C []*TestVersion3 `protobuf:"bytes,4,rep,name=c,proto3" json:"c,omitempty"`
	D []*TestVersion3 `protobuf:"bytes,5,rep,name=d,proto3" json:"d,omitempty"`
	// Types that are assignable to Sum:
	//	*TestVersion3LoneOneOfValue_E
	Sum              isTestVersion3LoneOneOfValue_Sum `protobuf_oneof:"sum"`
	G                *anypb.Any                       `protobuf:"bytes,8,opt,name=g,proto3" json:"g,omitempty"`
	H                []*TestVersion1                  `protobuf:"bytes,9,rep,name=h,proto3" json:"h,omitempty"`
	K                *Customer1                       `protobuf:"bytes,12,opt,name=k,proto3" json:"k,omitempty"`
	NonCriticalField string                           `protobuf:"bytes,1031,opt,name=non_critical_field,json=nonCriticalField,proto3" json:"non_critical_field,omitempty"`
}

func (x *TestVersion3LoneOneOfValue) Reset() {
	*x = TestVersion3LoneOneOfValue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion3LoneOneOfValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion3LoneOneOfValue) ProtoMessage() {}

func (x *TestVersion3LoneOneOfValue) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion3LoneOneOfValue) GetX() int64 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *TestVersion3LoneOneOfValue) GetA() *TestVersion3 {
	if x != nil {
		return x.A
	}
	return nil
}

func (x *TestVersion3LoneOneOfValue) GetB() *TestVersion3 {
	if x != nil {
		return x.B
	}
	return nil
}

func (x *TestVersion3LoneOneOfValue) GetC() []*TestVersion3 {
	if x != nil {
		return x.C
	}
	return nil
}

func (x *TestVersion3LoneOneOfValue) GetD() []*TestVersion3 {
	if x != nil {
		return x.D
	}
	return nil
}

func (m *TestVersion3LoneOneOfValue) GetSum() isTestVersion3LoneOneOfValue_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (x *TestVersion3LoneOneOfValue) GetE() int32 {
	if x, ok := x.GetSum().(*TestVersion3LoneOneOfValue_E); ok {
		return x.E
	}
	return 0
}

func (x *TestVersion3LoneOneOfValue) GetG() *anypb.Any {
	if x != nil {
		return x.G
	}
	return nil
}

func (x *TestVersion3LoneOneOfValue) GetH() []*TestVersion1 {
	if x != nil {
		return x.H
	}
	return nil
}

func (x *TestVersion3LoneOneOfValue) GetK() *Customer1 {
	if x != nil {
		return x.K
	}
	return nil
}

func (x *TestVersion3LoneOneOfValue) GetNonCriticalField() string {
	if x != nil {
		return x.NonCriticalField
	}
	return ""
}

type isTestVersion3LoneOneOfValue_Sum interface {
	isTestVersion3LoneOneOfValue_Sum()
}

type TestVersion3LoneOneOfValue_E struct {
	E int32 `protobuf:"varint,6,opt,name=e,proto3,oneof"`
}

func (*TestVersion3LoneOneOfValue_E) isTestVersion3LoneOneOfValue_Sum() {}

// returns the fast methods for the message
func (x TestVersion3LoneOneOfValue) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3LoneOneOfValue)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion3LoneOneOfValue does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3LoneOneOfValue)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion3LoneOneOfValue does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion3LoneOneOfValue) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion3LoneOneOfValue) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion3LoneOneOfValue) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion3LoneOneOfValue) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion3LoneOneOfValue) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion3LoneOneOfValue) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneOneOfValue) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _TestVersion3LoneOneOfValue_4_list struct {
	list []*TestVersion3
}

var _ protoreflect.List = (*_TestVersion3LoneOneOfValue_4_list)(nil)

func (x *_TestVersion3LoneOneOfValue_4_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion3LoneOneOfValue_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion3LoneOneOfValue_4_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list[i] = concreteValue
}

func (x *_TestVersion3LoneOneOfValue_4_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion3LoneOneOfValue_4_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3LoneOneOfValue_4_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion3LoneOneOfValue_4_list) NewElement() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3LoneOneOfValue_4_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestVersion3LoneOneOfValue_5_list struct {
	list []*TestVersion3
}

var _ protoreflect.List = (*_TestVersion3LoneOneOfValue_5_list)(nil)

func (x *_TestVersion3LoneOneOfValue_5_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion3LoneOneOfValue_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion3LoneOneOfValue_5_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list[i] = concreteValue
}

func (x *_TestVersion3LoneOneOfValue_5_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion3LoneOneOfValue_5_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3LoneOneOfValue_5_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion3LoneOneOfValue_5_list) NewElement() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3LoneOneOfValue_5_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestVersion3LoneOneOfValue_9_list struct {
	list []*TestVersion1
}

var _ protoreflect.List = (*_TestVersion3LoneOneOfValue_9_list)(nil)

func (x *_TestVersion3LoneOneOfValue_9_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion3LoneOneOfValue_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion3LoneOneOfValue_9_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list[i] = concreteValue
}

func (x *_TestVersion3LoneOneOfValue_9_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion3LoneOneOfValue_9_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3LoneOneOfValue_9_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion3LoneOneOfValue_9_list) NewElement() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3LoneOneOfValue_9_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion3LoneOneOfValue) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "x":
		return protoreflect.ValueOfInt64(x.X)
	case "a":
		return protoreflect.ValueOfMessage(x.A)
	case "b":
		return protoreflect.ValueOfMessage(x.B)
	case "c":
	case "d":
	case "e":
		return protoreflect.ValueOfInt32(x.GetE())
	case "g":
		return protoreflect.ValueOfMessage(x.G)
	case "h":
	case "k":
		return protoreflect.ValueOfMessage(x.K)
	case "non_critical_field":
		return protoreflect.ValueOfString(x.NonCriticalField)
	default:
		panic(fmt.Errorf("message testdata.TestVersion3LoneOneOfValue does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneOneOfValue) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneOneOfValue) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion3LoneOneOfValue) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion3LoneOneOfValue) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion3LoneOneOfValue) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneOneOfValue) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion3LoneOneOfValue) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion3LoneOneOfValue) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion3LoneNesting struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	X int64           `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	A *TestVersion3   `protobuf:"bytes,2,opt,name=a,proto3" json:"a,omitempty"`
	B *TestVersion3   `protobuf:"bytes,3,opt,name=b,proto3" json:"b,omitempty"`
	C []*TestVersion3 `protobuf:"bytes,4,rep,name=c,proto3" json:"c,omitempty"`
	D []*TestVersion3 `protobuf:"bytes,5,rep,name=d,proto3" json:"d,omitempty"`
	// Types that are assignable to Sum:
	//	*TestVersion3LoneNesting_F
	Sum              isTestVersion3LoneNesting_Sum   `protobuf_oneof:"sum"`
	G                *anypb.Any                      `protobuf:"bytes,8,opt,name=g,proto3" json:"g,omitempty"`
	H                []*TestVersion1                 `protobuf:"bytes,9,rep,name=h,proto3" json:"h,omitempty"`
	K                *Customer1                      `protobuf:"bytes,12,opt,name=k,proto3" json:"k,omitempty"`
	NonCriticalField string                          `protobuf:"bytes,1031,opt,name=non_critical_field,json=nonCriticalField,proto3" json:"non_critical_field,omitempty"`
	Inner1           *TestVersion3LoneNesting_Inner1 `protobuf:"bytes,14,opt,name=inner1,proto3" json:"inner1,omitempty"`
	Inner2           *TestVersion3LoneNesting_Inner2 `protobuf:"bytes,15,opt,name=inner2,proto3" json:"inner2,omitempty"`
}

func (x *TestVersion3LoneNesting) Reset() {
	*x = TestVersion3LoneNesting{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion3LoneNesting) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion3LoneNesting) ProtoMessage() {}

func (x *TestVersion3LoneNesting) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion3LoneNesting) GetX() int64 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *TestVersion3LoneNesting) GetA() *TestVersion3 {
	if x != nil {
		return x.A
	}
	return nil
}

func (x *TestVersion3LoneNesting) GetB() *TestVersion3 {
	if x != nil {
		return x.B
	}
	return nil
}

func (x *TestVersion3LoneNesting) GetC() []*TestVersion3 {
	if x != nil {
		return x.C
	}
	return nil
}

func (x *TestVersion3LoneNesting) GetD() []*TestVersion3 {
	if x != nil {
		return x.D
	}
	return nil
}

func (m *TestVersion3LoneNesting) GetSum() isTestVersion3LoneNesting_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (x *TestVersion3LoneNesting) GetF() *TestVersion3LoneNesting {
	if x, ok := x.GetSum().(*TestVersion3LoneNesting_F); ok {
		return x.F
	}
	return nil
}

func (x *TestVersion3LoneNesting) GetG() *anypb.Any {
	if x != nil {
		return x.G
	}
	return nil
}

func (x *TestVersion3LoneNesting) GetH() []*TestVersion1 {
	if x != nil {
		return x.H
	}
	return nil
}

func (x *TestVersion3LoneNesting) GetK() *Customer1 {
	if x != nil {
		return x.K
	}
	return nil
}

func (x *TestVersion3LoneNesting) GetNonCriticalField() string {
	if x != nil {
		return x.NonCriticalField
	}
	return ""
}

func (x *TestVersion3LoneNesting) GetInner1() *TestVersion3LoneNesting_Inner1 {
	if x != nil {
		return x.Inner1
	}
	return nil
}

func (x *TestVersion3LoneNesting) GetInner2() *TestVersion3LoneNesting_Inner2 {
	if x != nil {
		return x.Inner2
	}
	return nil
}

type isTestVersion3LoneNesting_Sum interface {
	isTestVersion3LoneNesting_Sum()
}

type TestVersion3LoneNesting_F struct {
	F *TestVersion3LoneNesting `protobuf:"bytes,7,opt,name=f,proto3,oneof"`
}

func (*TestVersion3LoneNesting_F) isTestVersion3LoneNesting_Sum() {}

// returns the fast methods for the message
func (x TestVersion3LoneNesting) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3LoneNesting)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion3LoneNesting does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3LoneNesting)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion3LoneNesting does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion3LoneNesting) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion3LoneNesting) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion3LoneNesting) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion3LoneNesting) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion3LoneNesting) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion3LoneNesting) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _TestVersion3LoneNesting_4_list struct {
	list []*TestVersion3
}

var _ protoreflect.List = (*_TestVersion3LoneNesting_4_list)(nil)

func (x *_TestVersion3LoneNesting_4_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion3LoneNesting_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion3LoneNesting_4_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list[i] = concreteValue
}

func (x *_TestVersion3LoneNesting_4_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion3LoneNesting_4_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3LoneNesting_4_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion3LoneNesting_4_list) NewElement() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3LoneNesting_4_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestVersion3LoneNesting_5_list struct {
	list []*TestVersion3
}

var _ protoreflect.List = (*_TestVersion3LoneNesting_5_list)(nil)

func (x *_TestVersion3LoneNesting_5_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion3LoneNesting_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion3LoneNesting_5_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list[i] = concreteValue
}

func (x *_TestVersion3LoneNesting_5_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion3LoneNesting_5_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3LoneNesting_5_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion3LoneNesting_5_list) NewElement() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3LoneNesting_5_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestVersion3LoneNesting_9_list struct {
	list []*TestVersion1
}

var _ protoreflect.List = (*_TestVersion3LoneNesting_9_list)(nil)

func (x *_TestVersion3LoneNesting_9_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion3LoneNesting_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion3LoneNesting_9_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list[i] = concreteValue
}

func (x *_TestVersion3LoneNesting_9_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion3LoneNesting_9_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3LoneNesting_9_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion3LoneNesting_9_list) NewElement() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion3LoneNesting_9_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion3LoneNesting) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "x":
		return protoreflect.ValueOfInt64(x.X)
	case "a":
		return protoreflect.ValueOfMessage(x.A)
	case "b":
		return protoreflect.ValueOfMessage(x.B)
	case "c":
	case "d":
	case "f":
		return protoreflect.ValueOfMessage(x.GetF())
	case "g":
		return protoreflect.ValueOfMessage(x.G)
	case "h":
	case "k":
		return protoreflect.ValueOfMessage(x.K)
	case "non_critical_field":
		return protoreflect.ValueOfString(x.NonCriticalField)
	case "inner1":
		return protoreflect.ValueOfMessage(x.Inner1)
	case "inner2":
		return protoreflect.ValueOfMessage(x.Inner2)
	default:
		panic(fmt.Errorf("message testdata.TestVersion3LoneNesting does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion3LoneNesting) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion3LoneNesting) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion3LoneNesting) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion3LoneNesting) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion3LoneNesting) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion4LoneNesting struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	X int64           `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	A *TestVersion3   `protobuf:"bytes,2,opt,name=a,proto3" json:"a,omitempty"`
	B *TestVersion3   `protobuf:"bytes,3,opt,name=b,proto3" json:"b,omitempty"`
	C []*TestVersion3 `protobuf:"bytes,4,rep,name=c,proto3" json:"c,omitempty"`
	D []*TestVersion3 `protobuf:"bytes,5,rep,name=d,proto3" json:"d,omitempty"`
	// Types that are assignable to Sum:
	//	*TestVersion4LoneNesting_F
	Sum              isTestVersion4LoneNesting_Sum   `protobuf_oneof:"sum"`
	G                *anypb.Any                      `protobuf:"bytes,8,opt,name=g,proto3" json:"g,omitempty"`
	H                []*TestVersion1                 `protobuf:"bytes,9,rep,name=h,proto3" json:"h,omitempty"`
	K                *Customer1                      `protobuf:"bytes,12,opt,name=k,proto3" json:"k,omitempty"`
	NonCriticalField string                          `protobuf:"bytes,1031,opt,name=non_critical_field,json=nonCriticalField,proto3" json:"non_critical_field,omitempty"`
	Inner1           *TestVersion4LoneNesting_Inner1 `protobuf:"bytes,14,opt,name=inner1,proto3" json:"inner1,omitempty"`
	Inner2           *TestVersion4LoneNesting_Inner2 `protobuf:"bytes,15,opt,name=inner2,proto3" json:"inner2,omitempty"`
}

func (x *TestVersion4LoneNesting) Reset() {
	*x = TestVersion4LoneNesting{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion4LoneNesting) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion4LoneNesting) ProtoMessage() {}

func (x *TestVersion4LoneNesting) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion4LoneNesting) GetX() int64 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *TestVersion4LoneNesting) GetA() *TestVersion3 {
	if x != nil {
		return x.A
	}
	return nil
}

func (x *TestVersion4LoneNesting) GetB() *TestVersion3 {
	if x != nil {
		return x.B
	}
	return nil
}

func (x *TestVersion4LoneNesting) GetC() []*TestVersion3 {
	if x != nil {
		return x.C
	}
	return nil
}

func (x *TestVersion4LoneNesting) GetD() []*TestVersion3 {
	if x != nil {
		return x.D
	}
	return nil
}

func (m *TestVersion4LoneNesting) GetSum() isTestVersion4LoneNesting_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (x *TestVersion4LoneNesting) GetF() *TestVersion3LoneNesting {
	if x, ok := x.GetSum().(*TestVersion4LoneNesting_F); ok {
		return x.F
	}
	return nil
}

func (x *TestVersion4LoneNesting) GetG() *anypb.Any {
	if x != nil {
		return x.G
	}
	return nil
}

func (x *TestVersion4LoneNesting) GetH() []*TestVersion1 {
	if x != nil {
		return x.H
	}
	return nil
}

func (x *TestVersion4LoneNesting) GetK() *Customer1 {
	if x != nil {
		return x.K
	}
	return nil
}

func (x *TestVersion4LoneNesting) GetNonCriticalField() string {
	if x != nil {
		return x.NonCriticalField
	}
	return ""
}

func (x *TestVersion4LoneNesting) GetInner1() *TestVersion4LoneNesting_Inner1 {
	if x != nil {
		return x.Inner1
	}
	return nil
}

func (x *TestVersion4LoneNesting) GetInner2() *TestVersion4LoneNesting_Inner2 {
	if x != nil {
		return x.Inner2
	}
	return nil
}

type isTestVersion4LoneNesting_Sum interface {
	isTestVersion4LoneNesting_Sum()
}

type TestVersion4LoneNesting_F struct {
	F *TestVersion3LoneNesting `protobuf:"bytes,7,opt,name=f,proto3,oneof"`
}

func (*TestVersion4LoneNesting_F) isTestVersion4LoneNesting_Sum() {}

// returns the fast methods for the message
func (x TestVersion4LoneNesting) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion4LoneNesting)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion4LoneNesting does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion4LoneNesting)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion4LoneNesting does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion4LoneNesting) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion4LoneNesting) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion4LoneNesting) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion4LoneNesting) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion4LoneNesting) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion4LoneNesting) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _TestVersion4LoneNesting_4_list struct {
	list []*TestVersion3
}

var _ protoreflect.List = (*_TestVersion4LoneNesting_4_list)(nil)

func (x *_TestVersion4LoneNesting_4_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion4LoneNesting_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion4LoneNesting_4_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list[i] = concreteValue
}

func (x *_TestVersion4LoneNesting_4_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion4LoneNesting_4_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion4LoneNesting_4_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion4LoneNesting_4_list) NewElement() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion4LoneNesting_4_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestVersion4LoneNesting_5_list struct {
	list []*TestVersion3
}

var _ protoreflect.List = (*_TestVersion4LoneNesting_5_list)(nil)

func (x *_TestVersion4LoneNesting_5_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion4LoneNesting_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion4LoneNesting_5_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list[i] = concreteValue
}

func (x *_TestVersion4LoneNesting_5_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion3)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion4LoneNesting_5_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion4LoneNesting_5_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion4LoneNesting_5_list) NewElement() protoreflect.Value {
	v := new(TestVersion3)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion4LoneNesting_5_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestVersion4LoneNesting_9_list struct {
	list []*TestVersion1
}

var _ protoreflect.List = (*_TestVersion4LoneNesting_9_list)(nil)

func (x *_TestVersion4LoneNesting_9_list) Len() int {
	return len(x.list)
}

func (x *_TestVersion4LoneNesting_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersion4LoneNesting_9_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list[i] = concreteValue
}

func (x *_TestVersion4LoneNesting_9_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersion4LoneNesting_9_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion4LoneNesting_9_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersion4LoneNesting_9_list) NewElement() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersion4LoneNesting_9_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion4LoneNesting) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "x":
		return protoreflect.ValueOfInt64(x.X)
	case "a":
		return protoreflect.ValueOfMessage(x.A)
	case "b":
		return protoreflect.ValueOfMessage(x.B)
	case "c":
	case "d":
	case "f":
		return protoreflect.ValueOfMessage(x.GetF())
	case "g":
		return protoreflect.ValueOfMessage(x.G)
	case "h":
	case "k":
		return protoreflect.ValueOfMessage(x.K)
	case "non_critical_field":
		return protoreflect.ValueOfString(x.NonCriticalField)
	case "inner1":
		return protoreflect.ValueOfMessage(x.Inner1)
	case "inner2":
		return protoreflect.ValueOfMessage(x.Inner2)
	default:
		panic(fmt.Errorf("message testdata.TestVersion4LoneNesting does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion4LoneNesting) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion4LoneNesting) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion4LoneNesting) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion4LoneNesting) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion4LoneNesting) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersionFD1 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	X int64         `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	A *TestVersion1 `protobuf:"bytes,2,opt,name=a,proto3" json:"a,omitempty"`
	// Types that are assignable to Sum:
	//	*TestVersionFD1_E
	//	*TestVersionFD1_F
	Sum isTestVersionFD1_Sum `protobuf_oneof:"sum"`
	G   *anypb.Any           `protobuf:"bytes,8,opt,name=g,proto3" json:"g,omitempty"`
	H   []*TestVersion1      `protobuf:"bytes,9,rep,name=h,proto3" json:"h,omitempty"`
}

func (x *TestVersionFD1) Reset() {
	*x = TestVersionFD1{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersionFD1) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersionFD1) ProtoMessage() {}

func (x *TestVersionFD1) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersionFD1) GetX() int64 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *TestVersionFD1) GetA() *TestVersion1 {
	if x != nil {
		return x.A
	}
	return nil
}

func (m *TestVersionFD1) GetSum() isTestVersionFD1_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (x *TestVersionFD1) GetE() int32 {
	if x, ok := x.GetSum().(*TestVersionFD1_E); ok {
		return x.E
	}
	return 0
}

func (x *TestVersionFD1) GetF() *TestVersion1 {
	if x, ok := x.GetSum().(*TestVersionFD1_F); ok {
		return x.F
	}
	return nil
}

func (x *TestVersionFD1) GetG() *anypb.Any {
	if x != nil {
		return x.G
	}
	return nil
}

func (x *TestVersionFD1) GetH() []*TestVersion1 {
	if x != nil {
		return x.H
	}
	return nil
}

type isTestVersionFD1_Sum interface {
	isTestVersionFD1_Sum()
}

type TestVersionFD1_E struct {
	E int32 `protobuf:"varint,6,opt,name=e,proto3,oneof"`
}

type TestVersionFD1_F struct {
	F *TestVersion1 `protobuf:"bytes,7,opt,name=f,proto3,oneof"`
}

func (*TestVersionFD1_E) isTestVersionFD1_Sum() {}

func (*TestVersionFD1_F) isTestVersionFD1_Sum() {}

// returns the fast methods for the message
func (x TestVersionFD1) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersionFD1)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersionFD1 does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersionFD1)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersionFD1 does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersionFD1) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersionFD1) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersionFD1) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersionFD1) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersionFD1) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersionFD1) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersionFD1) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _TestVersionFD1_9_list struct {
	list []*TestVersion1
}

var _ protoreflect.List = (*_TestVersionFD1_9_list)(nil)

func (x *_TestVersionFD1_9_list) Len() int {
	return len(x.list)
}

func (x *_TestVersionFD1_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersionFD1_9_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list[i] = concreteValue
}

func (x *_TestVersionFD1_9_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersionFD1_9_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersionFD1_9_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersionFD1_9_list) NewElement() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersionFD1_9_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersionFD1) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "x":
		return protoreflect.ValueOfInt64(x.X)
	case "a":
		return protoreflect.ValueOfMessage(x.A)
	case "e":
		return protoreflect.ValueOfInt32(x.GetE())
	case "f":
		return protoreflect.ValueOfMessage(x.GetF())
	case "g":
		return protoreflect.ValueOfMessage(x.G)
	case "h":
	default:
		panic(fmt.Errorf("message testdata.TestVersionFD1 does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersionFD1) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersionFD1) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersionFD1) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersionFD1) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersionFD1) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersionFD1) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersionFD1) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersionFD1) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersionFD1WithExtraAny struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	X int64         `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	A *TestVersion1 `protobuf:"bytes,2,opt,name=a,proto3" json:"a,omitempty"`
	// Types that are assignable to Sum:
	//	*TestVersionFD1WithExtraAny_E
	//	*TestVersionFD1WithExtraAny_F
	Sum isTestVersionFD1WithExtraAny_Sum `protobuf_oneof:"sum"`
	G   *AnyWithExtra                    `protobuf:"bytes,8,opt,name=g,proto3" json:"g,omitempty"`
	H   []*TestVersion1                  `protobuf:"bytes,9,rep,name=h,proto3" json:"h,omitempty"`
}

func (x *TestVersionFD1WithExtraAny) Reset() {
	*x = TestVersionFD1WithExtraAny{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersionFD1WithExtraAny) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersionFD1WithExtraAny) ProtoMessage() {}

func (x *TestVersionFD1WithExtraAny) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersionFD1WithExtraAny) GetX() int64 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *TestVersionFD1WithExtraAny) GetA() *TestVersion1 {
	if x != nil {
		return x.A
	}
	return nil
}

func (m *TestVersionFD1WithExtraAny) GetSum() isTestVersionFD1WithExtraAny_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (x *TestVersionFD1WithExtraAny) GetE() int32 {
	if x, ok := x.GetSum().(*TestVersionFD1WithExtraAny_E); ok {
		return x.E
	}
	return 0
}

func (x *TestVersionFD1WithExtraAny) GetF() *TestVersion1 {
	if x, ok := x.GetSum().(*TestVersionFD1WithExtraAny_F); ok {
		return x.F
	}
	return nil
}

func (x *TestVersionFD1WithExtraAny) GetG() *AnyWithExtra {
	if x != nil {
		return x.G
	}
	return nil
}

func (x *TestVersionFD1WithExtraAny) GetH() []*TestVersion1 {
	if x != nil {
		return x.H
	}
	return nil
}

type isTestVersionFD1WithExtraAny_Sum interface {
	isTestVersionFD1WithExtraAny_Sum()
}

type TestVersionFD1WithExtraAny_E struct {
	E int32 `protobuf:"varint,6,opt,name=e,proto3,oneof"`
}

type TestVersionFD1WithExtraAny_F struct {
	F *TestVersion1 `protobuf:"bytes,7,opt,name=f,proto3,oneof"`
}

func (*TestVersionFD1WithExtraAny_E) isTestVersionFD1WithExtraAny_Sum() {}

func (*TestVersionFD1WithExtraAny_F) isTestVersionFD1WithExtraAny_Sum() {}

// returns the fast methods for the message
func (x TestVersionFD1WithExtraAny) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersionFD1WithExtraAny)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersionFD1WithExtraAny does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersionFD1WithExtraAny)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersionFD1WithExtraAny does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersionFD1WithExtraAny) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersionFD1WithExtraAny) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersionFD1WithExtraAny) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersionFD1WithExtraAny) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersionFD1WithExtraAny) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersionFD1WithExtraAny) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersionFD1WithExtraAny) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _TestVersionFD1WithExtraAny_9_list struct {
	list []*TestVersion1
}

var _ protoreflect.List = (*_TestVersionFD1WithExtraAny_9_list)(nil)

func (x *_TestVersionFD1WithExtraAny_9_list) Len() int {
	return len(x.list)
}

func (x *_TestVersionFD1WithExtraAny_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestVersionFD1WithExtraAny_9_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list[i] = concreteValue
}

func (x *_TestVersionFD1WithExtraAny_9_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*TestVersion1)
	x.list = append(x.list, concreteValue)
}

func (x *_TestVersionFD1WithExtraAny_9_list) AppendMutable() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersionFD1WithExtraAny_9_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestVersionFD1WithExtraAny_9_list) NewElement() protoreflect.Value {
	v := new(TestVersion1)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestVersionFD1WithExtraAny_9_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersionFD1WithExtraAny) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "x":
		return protoreflect.ValueOfInt64(x.X)
	case "a":
		return protoreflect.ValueOfMessage(x.A)
	case "e":
		return protoreflect.ValueOfInt32(x.GetE())
	case "f":
		return protoreflect.ValueOfMessage(x.GetF())
	case "g":
		return protoreflect.ValueOfMessage(x.G)
	case "h":
	default:
		panic(fmt.Errorf("message testdata.TestVersionFD1WithExtraAny does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersionFD1WithExtraAny) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersionFD1WithExtraAny) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersionFD1WithExtraAny) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersionFD1WithExtraAny) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersionFD1WithExtraAny) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersionFD1WithExtraAny) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersionFD1WithExtraAny) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersionFD1WithExtraAny) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type AnyWithExtra struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	A *anypb.Any `protobuf:"bytes,1,opt,name=a,proto3" json:"a,omitempty"`
	B int64      `protobuf:"varint,3,opt,name=b,proto3" json:"b,omitempty"`
	C int64      `protobuf:"varint,4,opt,name=c,proto3" json:"c,omitempty"`
}

func (x *AnyWithExtra) Reset() {
	*x = AnyWithExtra{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AnyWithExtra) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AnyWithExtra) ProtoMessage() {}

func (x *AnyWithExtra) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AnyWithExtra) GetA() *anypb.Any {
	if x != nil {
		return x.A
	}
	return nil
}

func (x *AnyWithExtra) GetB() int64 {
	if x != nil {
		return x.B
	}
	return 0
}

func (x *AnyWithExtra) GetC() int64 {
	if x != nil {
		return x.C
	}
	return 0
}

// returns the fast methods for the message
func (x AnyWithExtra) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*AnyWithExtra)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("AnyWithExtra does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*AnyWithExtra)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("AnyWithExtra does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x AnyWithExtra) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x AnyWithExtra) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x AnyWithExtra) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x AnyWithExtra) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x AnyWithExtra) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x AnyWithExtra) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x AnyWithExtra) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *AnyWithExtra) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "a":
		return protoreflect.ValueOfMessage(x.A)
	case "b":
		return protoreflect.ValueOfInt64(x.B)
	case "c":
		return protoreflect.ValueOfInt64(x.C)
	default:
		panic(fmt.Errorf("message testdata.AnyWithExtra does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x AnyWithExtra) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x AnyWithExtra) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x AnyWithExtra) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x AnyWithExtra) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x AnyWithExtra) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x AnyWithExtra) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x AnyWithExtra) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x AnyWithExtra) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestUpdatedTxRaw struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	BodyBytes     []byte   `protobuf:"bytes,1,opt,name=body_bytes,json=bodyBytes,proto3" json:"body_bytes,omitempty"`
	AuthInfoBytes []byte   `protobuf:"bytes,2,opt,name=auth_info_bytes,json=authInfoBytes,proto3" json:"auth_info_bytes,omitempty"`
	Signatures    [][]byte `protobuf:"bytes,3,rep,name=signatures,proto3" json:"signatures,omitempty"`
	NewField_5    []byte   `protobuf:"bytes,5,opt,name=new_field_5,json=newField5,proto3" json:"new_field_5,omitempty"`
	NewField_1024 []byte   `protobuf:"bytes,1024,opt,name=new_field_1024,json=newField1024,proto3" json:"new_field_1024,omitempty"`
}

func (x *TestUpdatedTxRaw) Reset() {
	*x = TestUpdatedTxRaw{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestUpdatedTxRaw) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestUpdatedTxRaw) ProtoMessage() {}

func (x *TestUpdatedTxRaw) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestUpdatedTxRaw) GetBodyBytes() []byte {
	if x != nil {
		return x.BodyBytes
	}
	return nil
}

func (x *TestUpdatedTxRaw) GetAuthInfoBytes() []byte {
	if x != nil {
		return x.AuthInfoBytes
	}
	return nil
}

func (x *TestUpdatedTxRaw) GetSignatures() [][]byte {
	if x != nil {
		return x.Signatures
	}
	return nil
}

func (x *TestUpdatedTxRaw) GetNewField_5() []byte {
	if x != nil {
		return x.NewField_5
	}
	return nil
}

func (x *TestUpdatedTxRaw) GetNewField_1024() []byte {
	if x != nil {
		return x.NewField_1024
	}
	return nil
}

// returns the fast methods for the message
func (x TestUpdatedTxRaw) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestUpdatedTxRaw)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestUpdatedTxRaw does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestUpdatedTxRaw)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestUpdatedTxRaw does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestUpdatedTxRaw) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestUpdatedTxRaw) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestUpdatedTxRaw) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestUpdatedTxRaw) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestUpdatedTxRaw) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestUpdatedTxRaw) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestUpdatedTxRaw) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _TestUpdatedTxRaw_3_list struct {
	list [][]byte
}

var _ protoreflect.List = (*_TestUpdatedTxRaw_3_list)(nil)

func (x *_TestUpdatedTxRaw_3_list) Len() int {
	return len(x.list)
}

func (x *_TestUpdatedTxRaw_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfBytes(x.list[i])
}

func (x *_TestUpdatedTxRaw_3_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Bytes()
	concreteValue := unwrapped
	x.list[i] = concreteValue
}

func (x *_TestUpdatedTxRaw_3_list) Append(value protoreflect.Value) {
	unwrapped := value.Bytes()
	concreteValue := unwrapped
	x.list = append(x.list, concreteValue)
}

func (x *_TestUpdatedTxRaw_3_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message TestUpdatedTxRaw at list field Signatures as it is not of Message kind"))
}

func (x *_TestUpdatedTxRaw_3_list) Truncate(n int) {
	x.list = x.list[:n]
}

func (x *_TestUpdatedTxRaw_3_list) NewElement() protoreflect.Value {
	v := nil
	return protoreflect.ValueOfBytes(v)
}

func (x *_TestUpdatedTxRaw_3_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestUpdatedTxRaw) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "body_bytes":
		return protoreflect.ValueOfBytes(x.BodyBytes)
	case "auth_info_bytes":
		return protoreflect.ValueOfBytes(x.AuthInfoBytes)
	case "signatures":
	case "new_field_5":
		return protoreflect.ValueOfBytes(x.NewField_5)
	case "new_field_1024":
		return protoreflect.ValueOfBytes(x.NewField_1024)
	default:
		panic(fmt.Errorf("message testdata.TestUpdatedTxRaw does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestUpdatedTxRaw) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestUpdatedTxRaw) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestUpdatedTxRaw) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestUpdatedTxRaw) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestUpdatedTxRaw) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestUpdatedTxRaw) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestUpdatedTxRaw) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestUpdatedTxRaw) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestUpdatedTxBody struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Messages                     []*anypb.Any `protobuf:"bytes,1,rep,name=messages,proto3" json:"messages,omitempty"`
	Memo                         string       `protobuf:"bytes,2,opt,name=memo,proto3" json:"memo,omitempty"`
	TimeoutHeight                int64        `protobuf:"varint,3,opt,name=timeout_height,json=timeoutHeight,proto3" json:"timeout_height,omitempty"`
	SomeNewField                 uint64       `protobuf:"varint,4,opt,name=some_new_field,json=someNewField,proto3" json:"some_new_field,omitempty"`
	SomeNewFieldNonCriticalField string       `protobuf:"bytes,1050,opt,name=some_new_field_non_critical_field,json=someNewFieldNonCriticalField,proto3" json:"some_new_field_non_critical_field,omitempty"`
	ExtensionOptions             []*anypb.Any `protobuf:"bytes,1023,rep,name=extension_options,json=extensionOptions,proto3" json:"extension_options,omitempty"`
	NonCriticalExtensionOptions  []*anypb.Any `protobuf:"bytes,2047,rep,name=non_critical_extension_options,json=nonCriticalExtensionOptions,proto3" json:"non_critical_extension_options,omitempty"`
}

func (x *TestUpdatedTxBody) Reset() {
	*x = TestUpdatedTxBody{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestUpdatedTxBody) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestUpdatedTxBody) ProtoMessage() {}

func (x *TestUpdatedTxBody) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestUpdatedTxBody) GetMessages() []*anypb.Any {
	if x != nil {
		return x.Messages
	}
	return nil
}

func (x *TestUpdatedTxBody) GetMemo() string {
	if x != nil {
		return x.Memo
	}
	return ""
}

func (x *TestUpdatedTxBody) GetTimeoutHeight() int64 {
	if x != nil {
		return x.TimeoutHeight
	}
	return 0
}

func (x *TestUpdatedTxBody) GetSomeNewField() uint64 {
	if x != nil {
		return x.SomeNewField
	}
	return 0
}

func (x *TestUpdatedTxBody) GetSomeNewFieldNonCriticalField() string {
	if x != nil {
		return x.SomeNewFieldNonCriticalField
	}
	return ""
}

func (x *TestUpdatedTxBody) GetExtensionOptions() []*anypb.Any {
	if x != nil {
		return x.ExtensionOptions
	}
	return nil
}

func (x *TestUpdatedTxBody) GetNonCriticalExtensionOptions() []*anypb.Any {
	if x != nil {
		return x.NonCriticalExtensionOptions
	}
	return nil
}

// returns the fast methods for the message
func (x TestUpdatedTxBody) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestUpdatedTxBody)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestUpdatedTxBody does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestUpdatedTxBody)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestUpdatedTxBody does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestUpdatedTxBody) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestUpdatedTxBody) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestUpdatedTxBody) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestUpdatedTxBody) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestUpdatedTxBody) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestUpdatedTxBody) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestUpdatedTxBody) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _TestUpdatedTxBody_1_list struct {
	list []*anypb.Any
}

var _ protoreflect.List = (*_TestUpdatedTxBody_1_list)(nil)

func (x *_TestUpdatedTxBody_1_list) Len() int {
	return len(x.list)
}

func (x *_TestUpdatedTxBody_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestUpdatedTxBody_1_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*anypb.Any)
	x.list[i] = concreteValue
}

func (x *_TestUpdatedTxBody_1_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*anypb.Any)
	x.list = append(x.list, concreteValue)
}

func (x *_TestUpdatedTxBody_1_list) AppendMutable() protoreflect.Value {
	v := new(anypb.Any)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestUpdatedTxBody_1_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestUpdatedTxBody_1_list) NewElement() protoreflect.Value {
	v := new(anypb.Any)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestUpdatedTxBody_1_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestUpdatedTxBody_1023_list struct {
	list []*anypb.Any
}

var _ protoreflect.List = (*_TestUpdatedTxBody_1023_list)(nil)

func (x *_TestUpdatedTxBody_1023_list) Len() int {
	return len(x.list)
}

func (x *_TestUpdatedTxBody_1023_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestUpdatedTxBody_1023_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*anypb.Any)
	x.list[i] = concreteValue
}

func (x *_TestUpdatedTxBody_1023_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*anypb.Any)
	x.list = append(x.list, concreteValue)
}

func (x *_TestUpdatedTxBody_1023_list) AppendMutable() protoreflect.Value {
	v := new(anypb.Any)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestUpdatedTxBody_1023_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestUpdatedTxBody_1023_list) NewElement() protoreflect.Value {
	v := new(anypb.Any)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestUpdatedTxBody_1023_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

type _TestUpdatedTxBody_2047_list struct {
	list []*anypb.Any
}

var _ protoreflect.List = (*_TestUpdatedTxBody_2047_list)(nil)

func (x *_TestUpdatedTxBody_2047_list) Len() int {
	return len(x.list)
}

func (x *_TestUpdatedTxBody_2047_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestUpdatedTxBody_2047_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*anypb.Any)
	x.list[i] = concreteValue
}

func (x *_TestUpdatedTxBody_2047_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*anypb.Any)
	x.list = append(x.list, concreteValue)
}

func (x *_TestUpdatedTxBody_2047_list) AppendMutable() protoreflect.Value {
	v := new(anypb.Any)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestUpdatedTxBody_2047_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestUpdatedTxBody_2047_list) NewElement() protoreflect.Value {
	v := new(anypb.Any)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestUpdatedTxBody_2047_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestUpdatedTxBody) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "messages":
	case "memo":
		return protoreflect.ValueOfString(x.Memo)
	case "timeout_height":
		return protoreflect.ValueOfInt64(x.TimeoutHeight)
	case "some_new_field":
		return protoreflect.ValueOfUint64(x.SomeNewField)
	case "some_new_field_non_critical_field":
		return protoreflect.ValueOfString(x.SomeNewFieldNonCriticalField)
	case "extension_options":
	case "non_critical_extension_options":
	default:
		panic(fmt.Errorf("message testdata.TestUpdatedTxBody does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestUpdatedTxBody) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestUpdatedTxBody) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestUpdatedTxBody) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestUpdatedTxBody) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestUpdatedTxBody) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestUpdatedTxBody) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestUpdatedTxBody) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestUpdatedTxBody) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestUpdatedAuthInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SignerInfos   []*v1beta1.SignerInfo `protobuf:"bytes,1,rep,name=signer_infos,json=signerInfos,proto3" json:"signer_infos,omitempty"`
	Fee           *v1beta1.Fee          `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee,omitempty"`
	NewField_3    []byte                `protobuf:"bytes,3,opt,name=new_field_3,json=newField3,proto3" json:"new_field_3,omitempty"`
	NewField_1024 []byte                `protobuf:"bytes,1024,opt,name=new_field_1024,json=newField1024,proto3" json:"new_field_1024,omitempty"`
}

func (x *TestUpdatedAuthInfo) Reset() {
	*x = TestUpdatedAuthInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestUpdatedAuthInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestUpdatedAuthInfo) ProtoMessage() {}

func (x *TestUpdatedAuthInfo) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestUpdatedAuthInfo) GetSignerInfos() []*v1beta1.SignerInfo {
	if x != nil {
		return x.SignerInfos
	}
	return nil
}

func (x *TestUpdatedAuthInfo) GetFee() *v1beta1.Fee {
	if x != nil {
		return x.Fee
	}
	return nil
}

func (x *TestUpdatedAuthInfo) GetNewField_3() []byte {
	if x != nil {
		return x.NewField_3
	}
	return nil
}

func (x *TestUpdatedAuthInfo) GetNewField_1024() []byte {
	if x != nil {
		return x.NewField_1024
	}
	return nil
}

// returns the fast methods for the message
func (x TestUpdatedAuthInfo) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestUpdatedAuthInfo)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestUpdatedAuthInfo does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestUpdatedAuthInfo)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestUpdatedAuthInfo does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestUpdatedAuthInfo) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestUpdatedAuthInfo) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestUpdatedAuthInfo) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestUpdatedAuthInfo) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestUpdatedAuthInfo) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestUpdatedAuthInfo) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestUpdatedAuthInfo) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _TestUpdatedAuthInfo_1_list struct {
	list []*v1beta1.SignerInfo
}

var _ protoreflect.List = (*_TestUpdatedAuthInfo_1_list)(nil)

func (x *_TestUpdatedAuthInfo_1_list) Len() int {
	return len(x.list)
}

func (x *_TestUpdatedAuthInfo_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage(x.list[i].ProtoReflect())
}

func (x *_TestUpdatedAuthInfo_1_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*v1beta1.SignerInfo)
	x.list[i] = concreteValue
}

func (x *_TestUpdatedAuthInfo_1_list) Append(value protoreflect.Value) {
	unwrapped := value.Message()
	concreteValue := unwrapped.Interface().(*v1beta1.SignerInfo)
	x.list = append(x.list, concreteValue)
}

func (x *_TestUpdatedAuthInfo_1_list) AppendMutable() protoreflect.Value {
	v := new(v1beta1.SignerInfo)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestUpdatedAuthInfo_1_list) Truncate(n int) {
	for i := n; i < len(x.list); i++ {
		x.list[i] = nil
	}
	x.list = x.list[:n]
}

func (x *_TestUpdatedAuthInfo_1_list) NewElement() protoreflect.Value {
	v := new(v1beta1.SignerInfo)
	x.list = append(x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_TestUpdatedAuthInfo_1_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestUpdatedAuthInfo) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "signer_infos":
	case "fee":
		return protoreflect.ValueOfMessage(x.Fee)
	case "new_field_3":
		return protoreflect.ValueOfBytes(x.NewField_3)
	case "new_field_1024":
		return protoreflect.ValueOfBytes(x.NewField_1024)
	default:
		panic(fmt.Errorf("message testdata.TestUpdatedAuthInfo does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestUpdatedAuthInfo) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestUpdatedAuthInfo) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestUpdatedAuthInfo) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestUpdatedAuthInfo) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestUpdatedAuthInfo) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestUpdatedAuthInfo) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestUpdatedAuthInfo) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestUpdatedAuthInfo) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestRepeatedUints struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nums []uint64 `protobuf:"varint,1,rep,packed,name=nums,proto3" json:"nums,omitempty"`
}

func (x *TestRepeatedUints) Reset() {
	*x = TestRepeatedUints{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestRepeatedUints) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestRepeatedUints) ProtoMessage() {}

func (x *TestRepeatedUints) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestRepeatedUints) GetNums() []uint64 {
	if x != nil {
		return x.Nums
	}
	return nil
}

// returns the fast methods for the message
func (x TestRepeatedUints) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestRepeatedUints)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestRepeatedUints does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestRepeatedUints)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestRepeatedUints does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestRepeatedUints) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestRepeatedUints) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestRepeatedUints) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestRepeatedUints) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestRepeatedUints) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestRepeatedUints) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestRepeatedUints) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

type _TestRepeatedUints_1_list struct {
	list []uint64
}

var _ protoreflect.List = (*_TestRepeatedUints_1_list)(nil)

func (x *_TestRepeatedUints_1_list) Len() int {
	return len(x.list)
}

func (x *_TestRepeatedUints_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfUint64(x.list[i])
}

func (x *_TestRepeatedUints_1_list) Set(i int, value protoreflect.Value) {
	unwrapped := value.Uint()
	concreteValue := unwrapped
	x.list[i] = concreteValue
}

func (x *_TestRepeatedUints_1_list) Append(value protoreflect.Value) {
	unwrapped := value.Uint()
	concreteValue := unwrapped
	x.list = append(x.list, concreteValue)
}

func (x *_TestRepeatedUints_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message TestRepeatedUints at list field Nums as it is not of Message kind"))
}

func (x *_TestRepeatedUints_1_list) Truncate(n int) {
	x.list = x.list[:n]
}

func (x *_TestRepeatedUints_1_list) NewElement() protoreflect.Value {
	v := uint64(0)
	return protoreflect.ValueOfUint64(v)
}

func (x *_TestRepeatedUints_1_list) IsValid() bool {
	return x.list == nil || len(x.list) == 0
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestRepeatedUints) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "nums":
	default:
		panic(fmt.Errorf("message testdata.TestRepeatedUints does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestRepeatedUints) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestRepeatedUints) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestRepeatedUints) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestRepeatedUints) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestRepeatedUints) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestRepeatedUints) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestRepeatedUints) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestRepeatedUints) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion3LoneNesting_Inner1 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id    int64                                      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name  string                                     `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Inner *TestVersion3LoneNesting_Inner1_InnerInner `protobuf:"bytes,3,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (x *TestVersion3LoneNesting_Inner1) Reset() {
	*x = TestVersion3LoneNesting_Inner1{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion3LoneNesting_Inner1) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion3LoneNesting_Inner1) ProtoMessage() {}

func (x *TestVersion3LoneNesting_Inner1) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion3LoneNesting_Inner1) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *TestVersion3LoneNesting_Inner1) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TestVersion3LoneNesting_Inner1) GetInner() *TestVersion3LoneNesting_Inner1_InnerInner {
	if x != nil {
		return x.Inner
	}
	return nil
}

// returns the fast methods for the message
func (x TestVersion3LoneNesting_Inner1) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3LoneNesting_Inner1)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion3LoneNesting_Inner1 does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3LoneNesting_Inner1)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion3LoneNesting_Inner1 does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion3LoneNesting_Inner1) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion3LoneNesting_Inner1) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion3LoneNesting_Inner1) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion3LoneNesting_Inner1) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion3LoneNesting_Inner1) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion3LoneNesting_Inner1) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner1) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion3LoneNesting_Inner1) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt64(x.Id)
	case "name":
		return protoreflect.ValueOfString(x.Name)
	case "inner":
		return protoreflect.ValueOfMessage(x.Inner)
	default:
		panic(fmt.Errorf("message testdata.TestVersion3LoneNesting.Inner1 does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner1) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner1) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion3LoneNesting_Inner1) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion3LoneNesting_Inner1) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion3LoneNesting_Inner1) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner1) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion3LoneNesting_Inner1) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion3LoneNesting_Inner1) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion3LoneNesting_Inner2 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id      string                                     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Country string                                     `protobuf:"bytes,2,opt,name=country,proto3" json:"country,omitempty"`
	Inner   *TestVersion3LoneNesting_Inner2_InnerInner `protobuf:"bytes,3,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (x *TestVersion3LoneNesting_Inner2) Reset() {
	*x = TestVersion3LoneNesting_Inner2{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion3LoneNesting_Inner2) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion3LoneNesting_Inner2) ProtoMessage() {}

func (x *TestVersion3LoneNesting_Inner2) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion3LoneNesting_Inner2) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TestVersion3LoneNesting_Inner2) GetCountry() string {
	if x != nil {
		return x.Country
	}
	return ""
}

func (x *TestVersion3LoneNesting_Inner2) GetInner() *TestVersion3LoneNesting_Inner2_InnerInner {
	if x != nil {
		return x.Inner
	}
	return nil
}

// returns the fast methods for the message
func (x TestVersion3LoneNesting_Inner2) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3LoneNesting_Inner2)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion3LoneNesting_Inner2 does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3LoneNesting_Inner2)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion3LoneNesting_Inner2 does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion3LoneNesting_Inner2) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion3LoneNesting_Inner2) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion3LoneNesting_Inner2) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion3LoneNesting_Inner2) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion3LoneNesting_Inner2) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion3LoneNesting_Inner2) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner2) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion3LoneNesting_Inner2) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfString(x.Id)
	case "country":
		return protoreflect.ValueOfString(x.Country)
	case "inner":
		return protoreflect.ValueOfMessage(x.Inner)
	default:
		panic(fmt.Errorf("message testdata.TestVersion3LoneNesting.Inner2 does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner2) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner2) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion3LoneNesting_Inner2) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion3LoneNesting_Inner2) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion3LoneNesting_Inner2) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner2) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion3LoneNesting_Inner2) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion3LoneNesting_Inner2) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion3LoneNesting_Inner1_InnerInner struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id   string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	City string `protobuf:"bytes,2,opt,name=city,proto3" json:"city,omitempty"`
}

func (x *TestVersion3LoneNesting_Inner1_InnerInner) Reset() {
	*x = TestVersion3LoneNesting_Inner1_InnerInner{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion3LoneNesting_Inner1_InnerInner) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion3LoneNesting_Inner1_InnerInner) ProtoMessage() {}

func (x *TestVersion3LoneNesting_Inner1_InnerInner) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion3LoneNesting_Inner1_InnerInner) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TestVersion3LoneNesting_Inner1_InnerInner) GetCity() string {
	if x != nil {
		return x.City
	}
	return ""
}

// returns the fast methods for the message
func (x TestVersion3LoneNesting_Inner1_InnerInner) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3LoneNesting_Inner1_InnerInner)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion3LoneNesting_Inner1_InnerInner does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3LoneNesting_Inner1_InnerInner)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion3LoneNesting_Inner1_InnerInner does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion3LoneNesting_Inner1_InnerInner) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion3LoneNesting_Inner1_InnerInner) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion3LoneNesting_Inner1_InnerInner) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion3LoneNesting_Inner1_InnerInner) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion3LoneNesting_Inner1_InnerInner) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion3LoneNesting_Inner1_InnerInner) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner1_InnerInner) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion3LoneNesting_Inner1_InnerInner) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfString(x.Id)
	case "city":
		return protoreflect.ValueOfString(x.City)
	default:
		panic(fmt.Errorf("message testdata.TestVersion3LoneNesting.Inner1.InnerInner does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner1_InnerInner) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner1_InnerInner) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion3LoneNesting_Inner1_InnerInner) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion3LoneNesting_Inner1_InnerInner) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion3LoneNesting_Inner1_InnerInner) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner1_InnerInner) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion3LoneNesting_Inner1_InnerInner) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion3LoneNesting_Inner1_InnerInner) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion3LoneNesting_Inner2_InnerInner struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id   string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	City string `protobuf:"bytes,2,opt,name=city,proto3" json:"city,omitempty"`
}

func (x *TestVersion3LoneNesting_Inner2_InnerInner) Reset() {
	*x = TestVersion3LoneNesting_Inner2_InnerInner{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion3LoneNesting_Inner2_InnerInner) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion3LoneNesting_Inner2_InnerInner) ProtoMessage() {}

func (x *TestVersion3LoneNesting_Inner2_InnerInner) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion3LoneNesting_Inner2_InnerInner) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TestVersion3LoneNesting_Inner2_InnerInner) GetCity() string {
	if x != nil {
		return x.City
	}
	return ""
}

// returns the fast methods for the message
func (x TestVersion3LoneNesting_Inner2_InnerInner) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3LoneNesting_Inner2_InnerInner)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion3LoneNesting_Inner2_InnerInner does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion3LoneNesting_Inner2_InnerInner)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion3LoneNesting_Inner2_InnerInner does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion3LoneNesting_Inner2_InnerInner) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion3LoneNesting_Inner2_InnerInner) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion3LoneNesting_Inner2_InnerInner) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion3LoneNesting_Inner2_InnerInner) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion3LoneNesting_Inner2_InnerInner) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion3LoneNesting_Inner2_InnerInner) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner2_InnerInner) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion3LoneNesting_Inner2_InnerInner) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfString(x.Id)
	case "city":
		return protoreflect.ValueOfString(x.City)
	default:
		panic(fmt.Errorf("message testdata.TestVersion3LoneNesting.Inner2.InnerInner does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner2_InnerInner) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner2_InnerInner) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion3LoneNesting_Inner2_InnerInner) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion3LoneNesting_Inner2_InnerInner) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion3LoneNesting_Inner2_InnerInner) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion3LoneNesting_Inner2_InnerInner) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion3LoneNesting_Inner2_InnerInner) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion3LoneNesting_Inner2_InnerInner) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion4LoneNesting_Inner1 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id    int64                                      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name  string                                     `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Inner *TestVersion4LoneNesting_Inner1_InnerInner `protobuf:"bytes,3,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (x *TestVersion4LoneNesting_Inner1) Reset() {
	*x = TestVersion4LoneNesting_Inner1{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion4LoneNesting_Inner1) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion4LoneNesting_Inner1) ProtoMessage() {}

func (x *TestVersion4LoneNesting_Inner1) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion4LoneNesting_Inner1) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *TestVersion4LoneNesting_Inner1) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TestVersion4LoneNesting_Inner1) GetInner() *TestVersion4LoneNesting_Inner1_InnerInner {
	if x != nil {
		return x.Inner
	}
	return nil
}

// returns the fast methods for the message
func (x TestVersion4LoneNesting_Inner1) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion4LoneNesting_Inner1)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion4LoneNesting_Inner1 does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion4LoneNesting_Inner1)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion4LoneNesting_Inner1 does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion4LoneNesting_Inner1) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion4LoneNesting_Inner1) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion4LoneNesting_Inner1) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion4LoneNesting_Inner1) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion4LoneNesting_Inner1) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion4LoneNesting_Inner1) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner1) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion4LoneNesting_Inner1) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt64(x.Id)
	case "name":
		return protoreflect.ValueOfString(x.Name)
	case "inner":
		return protoreflect.ValueOfMessage(x.Inner)
	default:
		panic(fmt.Errorf("message testdata.TestVersion4LoneNesting.Inner1 does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner1) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner1) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion4LoneNesting_Inner1) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion4LoneNesting_Inner1) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion4LoneNesting_Inner1) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner1) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion4LoneNesting_Inner1) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion4LoneNesting_Inner1) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion4LoneNesting_Inner2 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id      string                                     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Country string                                     `protobuf:"bytes,2,opt,name=country,proto3" json:"country,omitempty"`
	Inner   *TestVersion4LoneNesting_Inner2_InnerInner `protobuf:"bytes,3,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (x *TestVersion4LoneNesting_Inner2) Reset() {
	*x = TestVersion4LoneNesting_Inner2{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion4LoneNesting_Inner2) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion4LoneNesting_Inner2) ProtoMessage() {}

func (x *TestVersion4LoneNesting_Inner2) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion4LoneNesting_Inner2) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TestVersion4LoneNesting_Inner2) GetCountry() string {
	if x != nil {
		return x.Country
	}
	return ""
}

func (x *TestVersion4LoneNesting_Inner2) GetInner() *TestVersion4LoneNesting_Inner2_InnerInner {
	if x != nil {
		return x.Inner
	}
	return nil
}

// returns the fast methods for the message
func (x TestVersion4LoneNesting_Inner2) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion4LoneNesting_Inner2)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion4LoneNesting_Inner2 does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion4LoneNesting_Inner2)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion4LoneNesting_Inner2 does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion4LoneNesting_Inner2) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion4LoneNesting_Inner2) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion4LoneNesting_Inner2) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion4LoneNesting_Inner2) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion4LoneNesting_Inner2) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion4LoneNesting_Inner2) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner2) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion4LoneNesting_Inner2) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfString(x.Id)
	case "country":
		return protoreflect.ValueOfString(x.Country)
	case "inner":
		return protoreflect.ValueOfMessage(x.Inner)
	default:
		panic(fmt.Errorf("message testdata.TestVersion4LoneNesting.Inner2 does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner2) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner2) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion4LoneNesting_Inner2) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion4LoneNesting_Inner2) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion4LoneNesting_Inner2) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner2) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion4LoneNesting_Inner2) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion4LoneNesting_Inner2) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion4LoneNesting_Inner1_InnerInner struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id   int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	City string `protobuf:"bytes,2,opt,name=city,proto3" json:"city,omitempty"`
}

func (x *TestVersion4LoneNesting_Inner1_InnerInner) Reset() {
	*x = TestVersion4LoneNesting_Inner1_InnerInner{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[31]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion4LoneNesting_Inner1_InnerInner) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion4LoneNesting_Inner1_InnerInner) ProtoMessage() {}

func (x *TestVersion4LoneNesting_Inner1_InnerInner) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[31]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion4LoneNesting_Inner1_InnerInner) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *TestVersion4LoneNesting_Inner1_InnerInner) GetCity() string {
	if x != nil {
		return x.City
	}
	return ""
}

// returns the fast methods for the message
func (x TestVersion4LoneNesting_Inner1_InnerInner) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion4LoneNesting_Inner1_InnerInner)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion4LoneNesting_Inner1_InnerInner does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion4LoneNesting_Inner1_InnerInner)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion4LoneNesting_Inner1_InnerInner does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion4LoneNesting_Inner1_InnerInner) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion4LoneNesting_Inner1_InnerInner) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion4LoneNesting_Inner1_InnerInner) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion4LoneNesting_Inner1_InnerInner) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion4LoneNesting_Inner1_InnerInner) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion4LoneNesting_Inner1_InnerInner) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner1_InnerInner) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion4LoneNesting_Inner1_InnerInner) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfInt64(x.Id)
	case "city":
		return protoreflect.ValueOfString(x.City)
	default:
		panic(fmt.Errorf("message testdata.TestVersion4LoneNesting.Inner1.InnerInner does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner1_InnerInner) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner1_InnerInner) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion4LoneNesting_Inner1_InnerInner) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion4LoneNesting_Inner1_InnerInner) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion4LoneNesting_Inner1_InnerInner) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner1_InnerInner) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion4LoneNesting_Inner1_InnerInner) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion4LoneNesting_Inner1_InnerInner) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

type TestVersion4LoneNesting_Inner2_InnerInner struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Value int64  `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *TestVersion4LoneNesting_Inner2_InnerInner) Reset() {
	*x = TestVersion4LoneNesting_Inner2_InnerInner{}
	if protoimpl.UnsafeEnabled {
		mi := &file_unknonwnproto_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TestVersion4LoneNesting_Inner2_InnerInner) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestVersion4LoneNesting_Inner2_InnerInner) ProtoMessage() {}

func (x *TestVersion4LoneNesting_Inner2_InnerInner) ProtoReflect() protoreflect.Message {
	mi := &file_unknonwnproto_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TestVersion4LoneNesting_Inner2_InnerInner) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TestVersion4LoneNesting_Inner2_InnerInner) GetValue() int64 {
	if x != nil {
		return x.Value
	}
	return 0
}

// returns the fast methods for the message
func (x TestVersion4LoneNesting_Inner2_InnerInner) GetMethods() *protoiface.Methods {
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             0,
		Size: func(input protoiface.SizeInput) protoiface.SizeOutput {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: struct{}{},
				Size:              x.Size(),
			}
		},
		Marshal: func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
			v, ok := input.Message.(*TestVersion4LoneNesting_Inner2_InnerInner)
			if !ok {
				return protoiface.MarshalOutput{}, errors.New("TestVersion4LoneNesting_Inner2_InnerInner does not implement the protoreflect.Message interface")
			}

			bz, err := v.Marshal()
			if err != nil {
				return protoiface.MarshalOutput{}, err
			}
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Buf:               bz,
			}, nil
		},
		Unmarshal: func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
			v, ok := input.Message.(*TestVersion4LoneNesting_Inner2_InnerInner)
			if !ok {
				return protoiface.UnmarshalOutput{}, errors.New("TestVersion4LoneNesting_Inner2_InnerInner does not implement the protoreflect.Message interface")
			}

			if len(input.Buf) < 1 {
				return protoiface.UnmarshalOutput{}, errors.New("unmarshal input did not contain any bytes to unmarshal")
			}
			err := v.Unmarshal(input.Buf)
			if err != nil {
				return protoiface.UnmarshalOutput{}, err
			}
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: struct{}{},
				Flags:             0,
			}, nil
		},
		Merge:            nil,
		CheckInitialized: nil,
	}
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x TestVersion4LoneNesting_Inner2_InnerInner) Descriptor() protoreflect.MessageDescriptor {
	return x.ProtoReflect().Descriptor()
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x TestVersion4LoneNesting_Inner2_InnerInner) Type() protoreflect.MessageType {
	return x.ProtoReflect().Type()
}

// New returns a newly allocated and mutable empty message.
func (x TestVersion4LoneNesting_Inner2_InnerInner) New() protoreflect.Message {
	return x.ProtoReflect().New()
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x TestVersion4LoneNesting_Inner2_InnerInner) Interface() protoreflect.ProtoMessage {
	return x.ProtoReflect().Interface()
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x TestVersion4LoneNesting_Inner2_InnerInner) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	x.ProtoReflect().Range(f)
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x TestVersion4LoneNesting_Inner2_InnerInner) Has(descriptor protoreflect.FieldDescriptor) bool {
	return x.ProtoReflect().Has(descriptor)
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner2_InnerInner) Clear(descriptor protoreflect.FieldDescriptor) {
	x.ProtoReflect().Clear(descriptor)
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *TestVersion4LoneNesting_Inner2_InnerInner) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.Name() {
	case "id":
		return protoreflect.ValueOfString(x.Id)
	case "value":
		return protoreflect.ValueOfInt64(x.Value)
	default:
		panic(fmt.Errorf("message testdata.TestVersion4LoneNesting.Inner2.InnerInner does not contain field %s", descriptor.Name()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner2_InnerInner) Set(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) {
	x.ProtoReflect().Set(descriptor, value)
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner2_InnerInner) Mutable(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().Mutable(descriptor)
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x TestVersion4LoneNesting_Inner2_InnerInner) NewField(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	return x.ProtoReflect().NewField(descriptor)
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x TestVersion4LoneNesting_Inner2_InnerInner) WhichOneof(descriptor protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	return x.ProtoReflect().WhichOneof(descriptor)
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x TestVersion4LoneNesting_Inner2_InnerInner) GetUnknown() protoreflect.RawFields {
	return x.ProtoReflect().GetUnknown()
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x TestVersion4LoneNesting_Inner2_InnerInner) SetUnknown(fields protoreflect.RawFields) {
	x.ProtoReflect().SetUnknown(fields)
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x TestVersion4LoneNesting_Inner2_InnerInner) IsValid() bool {
	return x.ProtoReflect().IsValid()
}

// ProtoMethods returns optional fast-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x TestVersion4LoneNesting_Inner2_InnerInner) ProtoMethods() *protoiface.Methods {
	return x.GetMethods()
}

var File_unknonwnproto_proto protoreflect.FileDescriptor

var file_unknonwnproto_proto_rawDesc = []byte{
	0x0a, 0x13, 0x75, 0x6e, 0x6b, 0x6e, 0x6f, 0x6e, 0x77, 0x6e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x1a,
	0x14, 0x67, 0x6f, 0x67, 0x6f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x61, 0x6e, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x1a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x74, 0x78, 0x2f, 0x76, 0x31, 0x62, 0x65,
	0x74, 0x61, 0x31, 0x2f, 0x74, 0x78, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x74, 0x0a, 0x09,
	0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x65, 0x72, 0x31, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x29, 0x0a,
	0x10, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x66, 0x65,
	0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0f, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x65, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x79, 0x6d,
	0x65, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x79, 0x6d, 0x65,
	0x6e, 0x74, 0x22, 0xb1, 0x02, 0x0a, 0x09, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x65, 0x72, 0x32,
	0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x69, 0x64,
	0x12, 0x1a, 0x0a, 0x08, 0x69, 0x6e, 0x64, 0x75, 0x73, 0x74, 0x72, 0x79, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x08, 0x69, 0x6e, 0x64, 0x75, 0x73, 0x74, 0x72, 0x79, 0x12, 0x12, 0x0a, 0x04,
	0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
	0x12, 0x14, 0x0a, 0x05, 0x66, 0x65, 0x77, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x52,
	0x05, 0x66, 0x65, 0x77, 0x65, 0x72, 0x12, 0x1b, 0x0a, 0x08, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76,
	0x65, 0x64, 0x18, 0x97, 0x08, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x72, 0x65, 0x73, 0x65, 0x72,
	0x76, 0x65, 0x64, 0x12, 0x2c, 0x0a, 0x04, 0x63, 0x69, 0x74, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x18, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x43, 0x75, 0x73,
	0x74, 0x6f, 0x6d, 0x65, 0x72, 0x32, 0x2e, 0x43, 0x69, 0x74, 0x79, 0x52, 0x04, 0x63, 0x69, 0x74,
	0x79, 0x12, 0x3a, 0x0a, 0x0d, 0x6d, 0x69, 0x73, 0x63, 0x65, 0x6c, 0x6c, 0x61, 0x6e, 0x65, 0x6f,
	0x75, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x41, 0x6e, 0x79, 0x52, 0x0d,
	0x6d, 0x69, 0x73, 0x63, 0x65, 0x6c, 0x6c, 0x61, 0x6e, 0x65, 0x6f, 0x75, 0x73, 0x22, 0x47, 0x0a,
	0x04, 0x43, 0x69, 0x74, 0x79, 0x12, 0x08, 0x0a, 0x04, 0x4c, 0x61, 0x6f, 0x73, 0x10, 0x00, 0x12,
	0x0e, 0x0a, 0x0a, 0x4c, 0x6f, 0x73, 0x41, 0x6e, 0x67, 0x65, 0x6c, 0x65, 0x73, 0x10, 0x01, 0x12,
	0x0c, 0x0a, 0x08, 0x50, 0x61, 0x6c, 0x6f, 0x41, 0x6c, 0x74, 0x6f, 0x10, 0x02, 0x12, 0x0a, 0x0a,
	0x06, 0x4d, 0x6f, 0x73, 0x63, 0x6f, 0x77, 0x10, 0x03, 0x12, 0x0b, 0x0a, 0x07, 0x4e, 0x61, 0x69,
	0x72, 0x6f, 0x62, 0x69, 0x10, 0x04, 0x22, 0x2e, 0x0a, 0x08, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64,
	0x34, 0x41, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02,
	0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0xd5, 0x01, 0x0a, 0x08, 0x4e, 0x65, 0x73, 0x74, 0x65,
	0x64, 0x33, 0x41, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x22, 0x0a, 0x02, 0x61, 0x34, 0x18, 0x04, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x4e,
	0x65, 0x73, 0x74, 0x65, 0x64, 0x34, 0x41, 0x52, 0x02, 0x61, 0x34, 0x12, 0x33, 0x0a, 0x05, 0x69,
	0x6e, 0x64, 0x65, 0x78, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x74, 0x65, 0x73,
	0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x33, 0x41, 0x2e, 0x49,
	0x6e, 0x64, 0x65, 0x78, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x05, 0x69, 0x6e, 0x64, 0x65, 0x78,
	0x1a, 0x4c, 0x0a, 0x0a, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
	0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x28, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x12, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x4e, 0x65, 0x73, 0x74, 0x65,
	0x64, 0x34, 0x41, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x5a,
	0x0a, 0x08, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x32, 0x41, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61,
	0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x2a,
	0x0a, 0x06, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12,
	0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64,
	0x33, 0x41, 0x52, 0x06, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x22, 0x46, 0x0a, 0x08, 0x4e, 0x65,
	0x73, 0x74, 0x65, 0x64, 0x31, 0x41, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x02, 0x69, 0x64, 0x12, 0x2a, 0x0a, 0x06, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74,
	0x61, 0x2e, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x32, 0x41, 0x52, 0x06, 0x6e, 0x65, 0x73, 0x74,
	0x65, 0x64, 0x22, 0x40, 0x0a, 0x08, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x34, 0x42, 0x12, 0x0e,
	0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x69, 0x64, 0x12, 0x10,
	0x0a, 0x03, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x61, 0x67, 0x65,
	0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x6e, 0x61, 0x6d, 0x65, 0x22, 0x64, 0x0a, 0x08, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x33, 0x42,
	0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x69, 0x64,
	0x12, 0x10, 0x0a, 0x03, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x61,
	0x67, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x22, 0x0a, 0x02, 0x62, 0x34, 0x18, 0x04, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x12, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x4e, 0x65,
	0x73, 0x74, 0x65, 0x64, 0x34, 0x42, 0x52, 0x02, 0x62, 0x34, 0x22, 0x6e, 0x0a, 0x08, 0x4e, 0x65,
	0x73, 0x74, 0x65, 0x64, 0x32, 0x42, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x02, 0x69, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x66, 0x65, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x01, 0x52, 0x03, 0x66, 0x65, 0x65, 0x12, 0x2a, 0x0a, 0x06, 0x6e, 0x65, 0x73, 0x74,
	0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64,
	0x61, 0x74, 0x61, 0x2e, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x33, 0x42, 0x52, 0x06, 0x6e, 0x65,
	0x73, 0x74, 0x65, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x22, 0x58, 0x0a, 0x08, 0x4e, 0x65,
	0x73, 0x74, 0x65, 0x64, 0x31, 0x42, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x02, 0x69, 0x64, 0x12, 0x2a, 0x0a, 0x06, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74,
	0x61, 0x2e, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x32, 0x42, 0x52, 0x06, 0x6e, 0x65, 0x73, 0x74,
	0x65, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x61, 0x67, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x03, 0x61, 0x67, 0x65, 0x22, 0x82, 0x02, 0x0a, 0x09, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x65,
	0x72, 0x33, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02,
	0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x73, 0x66, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x02, 0x52, 0x02, 0x73, 0x66, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x75, 0x72, 0x63, 0x68, 0x61,
	0x72, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x52, 0x09, 0x73, 0x75, 0x72, 0x63, 0x68,
	0x61, 0x72, 0x67, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69,
	0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x26, 0x0a, 0x0e, 0x63, 0x72, 0x65, 0x64, 0x69, 0x74,
	0x5f, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x6e, 0x6f, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00,
	0x52, 0x0c, 0x63, 0x72, 0x65, 0x64, 0x69, 0x74, 0x43, 0x61, 0x72, 0x64, 0x4e, 0x6f, 0x12, 0x1d,
	0x0a, 0x09, 0x63, 0x68, 0x65, 0x71, 0x75, 0x65, 0x5f, 0x6e, 0x6f, 0x18, 0x08, 0x20, 0x01, 0x28,
	0x09, 0x48, 0x00, 0x52, 0x08, 0x63, 0x68, 0x65, 0x71, 0x75, 0x65, 0x4e, 0x6f, 0x12, 0x2f, 0x0a,
	0x08, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x13, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f,
	0x6d, 0x65, 0x72, 0x31, 0x52, 0x08, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x42, 0x09,
	0x0a, 0x07, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x22, 0xec, 0x02, 0x0a, 0x0c, 0x54, 0x65,
	0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31, 0x12, 0x0c, 0x0a, 0x01, 0x78, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x01, 0x78, 0x12, 0x24, 0x0a, 0x01, 0x61, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54,
	0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31, 0x52, 0x01, 0x61, 0x12, 0x24,
	0x0a, 0x01, 0x62, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74,
	0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
	0x31, 0x52, 0x01, 0x62, 0x12, 0x24, 0x0a, 0x01, 0x63, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31, 0x52, 0x01, 0x63, 0x12, 0x2a, 0x0a, 0x01, 0x64, 0x18,
	0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61,
	0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31, 0x42, 0x04, 0xc8,
	0xde, 0x1f, 0x00, 0x52, 0x01, 0x64, 0x12, 0x0e, 0x0a, 0x01, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x05, 0x48, 0x00, 0x52, 0x01, 0x65, 0x12, 0x26, 0x0a, 0x01, 0x66, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73,
	0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31, 0x48, 0x00, 0x52, 0x01, 0x66, 0x12, 0x22,
	0x0a, 0x01, 0x67, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x41, 0x6e, 0x79, 0x52,
	0x01, 0x67, 0x12, 0x24, 0x0a, 0x01, 0x68, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e,
	0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x31, 0x52, 0x01, 0x68, 0x12, 0x27, 0x0a, 0x01, 0x6b, 0x18, 0x0c, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x43,
	0x75, 0x73, 0x74, 0x6f, 0x6d, 0x65, 0x72, 0x31, 0x42, 0x04, 0xd0, 0xde, 0x1f, 0x01, 0x52, 0x01,
	0x6b, 0x42, 0x05, 0x0a, 0x03, 0x73, 0x75, 0x6d, 0x22, 0x83, 0x03, 0x0a, 0x0c, 0x54, 0x65, 0x73,
	0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x32, 0x12, 0x0c, 0x0a, 0x01, 0x78, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x01, 0x78, 0x12, 0x24, 0x0a, 0x01, 0x61, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65,
	0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x32, 0x52, 0x01, 0x61, 0x12, 0x24, 0x0a,
	0x01, 0x62, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64,
	0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x32,
	0x52, 0x01, 0x62, 0x12, 0x24, 0x0a, 0x01, 0x63, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16,
	0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65,
	0x72, 0x73, 0x69, 0x6f, 0x6e, 0x32, 0x52, 0x01, 0x63, 0x12, 0x24, 0x0a, 0x01, 0x64, 0x18, 0x05,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e,
	0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x32, 0x52, 0x01, 0x64, 0x12,
	0x0e, 0x0a, 0x01, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x01, 0x65, 0x12,
	0x26, 0x0a, 0x01, 0x66, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73,
	0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f,
	0x6e, 0x32, 0x48, 0x00, 0x52, 0x01, 0x66, 0x12, 0x22, 0x0a, 0x01, 0x67, 0x18, 0x08, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x41, 0x6e, 0x79, 0x52, 0x01, 0x67, 0x12, 0x24, 0x0a, 0x01, 0x68,
	0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74,
	0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31, 0x52, 0x01,
	0x68, 0x12, 0x27, 0x0a, 0x01, 0x6b, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x74,
	0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x65, 0x72,
	0x31, 0x42, 0x04, 0xd0, 0xde, 0x1f, 0x01, 0x52, 0x01, 0x6b, 0x12, 0x1b, 0x0a, 0x09, 0x6e, 0x65,
	0x77, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x18, 0x19, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x6e,
	0x65, 0x77, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x42, 0x05, 0x0a, 0x03, 0x73, 0x75, 0x6d, 0x22, 0x95,
	0x03, 0x0a, 0x0c, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x12,
	0x0c, 0x0a, 0x01, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x01, 0x78, 0x12, 0x24, 0x0a,
	0x01, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64,
	0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33,
	0x52, 0x01, 0x61, 0x12, 0x24, 0x0a, 0x01, 0x62, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
	0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65,
	0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x52, 0x01, 0x62, 0x12, 0x24, 0x0a, 0x01, 0x63, 0x18, 0x04,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e,
	0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x52, 0x01, 0x63, 0x12,
	0x24, 0x0a, 0x01, 0x64, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73,
	0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f,
	0x6e, 0x33, 0x52, 0x01, 0x64, 0x12, 0x0e, 0x0a, 0x01, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05,
	0x48, 0x00, 0x52, 0x01, 0x65, 0x12, 0x26, 0x0a, 0x01, 0x66, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74,
	0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x48, 0x00, 0x52, 0x01, 0x66, 0x12, 0x22, 0x0a,
	0x01, 0x67, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x41, 0x6e, 0x79, 0x52, 0x01,
	0x67, 0x12, 0x24, 0x0a, 0x01, 0x68, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74,
	0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73,
	0x69, 0x6f, 0x6e, 0x31, 0x52, 0x01, 0x68, 0x12, 0x27, 0x0a, 0x01, 0x6b, 0x18, 0x0c, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x13, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x43, 0x75,
	0x73, 0x74, 0x6f, 0x6d, 0x65, 0x72, 0x31, 0x42, 0x04, 0xd0, 0xde, 0x1f, 0x01, 0x52, 0x01, 0x6b,
	0x12, 0x2d, 0x0a, 0x12, 0x6e, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c,
	0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x18, 0x87, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x6e,
	0x6f, 0x6e, 0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x42,
	0x05, 0x0a, 0x03, 0x73, 0x75, 0x6d, 0x22, 0xfb, 0x02, 0x0a, 0x1a, 0x54, 0x65, 0x73, 0x74, 0x56,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x4c, 0x6f, 0x6e, 0x65, 0x4f, 0x6e, 0x65, 0x4f, 0x66,
	0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x0c, 0x0a, 0x01, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03,
	0x52, 0x01, 0x78, 0x12, 0x24, 0x0a, 0x01, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
	0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65,
	0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x52, 0x01, 0x61, 0x12, 0x24, 0x0a, 0x01, 0x62, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e,
	0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x52, 0x01, 0x62, 0x12,
	0x24, 0x0a, 0x01, 0x63, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73,
	0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f,
	0x6e, 0x33, 0x52, 0x01, 0x63, 0x12, 0x24, 0x0a, 0x01, 0x64, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74,
	0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x52, 0x01, 0x64, 0x12, 0x0e, 0x0a, 0x01, 0x65,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x01, 0x65, 0x12, 0x22, 0x0a, 0x01, 0x67,
	0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x41, 0x6e, 0x79, 0x52, 0x01, 0x67, 0x12,
	0x24, 0x0a, 0x01, 0x68, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73,
	0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f,
	0x6e, 0x31, 0x52, 0x01, 0x68, 0x12, 0x27, 0x0a, 0x01, 0x6b, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x13, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x43, 0x75, 0x73, 0x74,
	0x6f, 0x6d, 0x65, 0x72, 0x31, 0x42, 0x04, 0xd0, 0xde, 0x1f, 0x01, 0x52, 0x01, 0x6b, 0x12, 0x2d,
	0x0a, 0x12, 0x6e, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x5f, 0x66,
	0x69, 0x65, 0x6c, 0x64, 0x18, 0x87, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x6e, 0x6f, 0x6e,
	0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x42, 0x05, 0x0a,
	0x03, 0x73, 0x75, 0x6d, 0x22, 0xfd, 0x06, 0x0a, 0x17, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x33, 0x4c, 0x6f, 0x6e, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67,
	0x12, 0x0c, 0x0a, 0x01, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x01, 0x78, 0x12, 0x24,
	0x0a, 0x01, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74,
	0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
	0x33, 0x52, 0x01, 0x61, 0x12, 0x24, 0x0a, 0x01, 0x62, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x52, 0x01, 0x62, 0x12, 0x24, 0x0a, 0x01, 0x63, 0x18,
	0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61,
	0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x52, 0x01, 0x63,
	0x12, 0x24, 0x0a, 0x01, 0x64, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65,
	0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x33, 0x52, 0x01, 0x64, 0x12, 0x31, 0x0a, 0x01, 0x66, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x21, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73,
	0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x4c, 0x6f, 0x6e, 0x65, 0x4e, 0x65, 0x73,
	0x74, 0x69, 0x6e, 0x67, 0x48, 0x00, 0x52, 0x01, 0x66, 0x12, 0x22, 0x0a, 0x01, 0x67, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x41, 0x6e, 0x79, 0x52, 0x01, 0x67, 0x12, 0x24, 0x0a,
	0x01, 0x68, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64,
	0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31,
	0x52, 0x01, 0x68, 0x12, 0x27, 0x0a, 0x01, 0x6b, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13,
	0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d,
	0x65, 0x72, 0x31, 0x42, 0x04, 0xd0, 0xde, 0x1f, 0x01, 0x52, 0x01, 0x6b, 0x12, 0x2d, 0x0a, 0x12,
	0x6e, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x5f, 0x66, 0x69, 0x65,
	0x6c, 0x64, 0x18, 0x87, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x6e, 0x6f, 0x6e, 0x43, 0x72,
	0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x12, 0x40, 0x0a, 0x06, 0x69,
	0x6e, 0x6e, 0x65, 0x72, 0x31, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x74, 0x65,
	0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x33, 0x4c, 0x6f, 0x6e, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x2e, 0x49,
	0x6e, 0x6e, 0x65, 0x72, 0x31, 0x52, 0x06, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x31, 0x12, 0x40, 0x0a,
	0x06, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x32, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e,
	0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x33, 0x4c, 0x6f, 0x6e, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67,
	0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x32, 0x52, 0x06, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x32, 0x1a,
	0xa9, 0x01, 0x0a, 0x06, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x31, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61,
	0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x49,
	0x0a, 0x05, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e,
	0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x33, 0x4c, 0x6f, 0x6e, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67,
	0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x31, 0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x6e,
	0x65, 0x72, 0x52, 0x05, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x1a, 0x30, 0x0a, 0x0a, 0x49, 0x6e, 0x6e,
	0x65, 0x72, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x69, 0x74, 0x79, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x69, 0x74, 0x79, 0x1a, 0xaf, 0x01, 0x0a, 0x06,
	0x49, 0x6e, 0x6e, 0x65, 0x72, 0x32, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72,
	0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79,
	0x12, 0x49, 0x0a, 0x05, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x33, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x4c, 0x6f, 0x6e, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x69,
	0x6e, 0x67, 0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x32, 0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x49,
	0x6e, 0x6e, 0x65, 0x72, 0x52, 0x05, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x1a, 0x30, 0x0a, 0x0a, 0x49,
	0x6e, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x69, 0x74,
	0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x69, 0x74, 0x79, 0x42, 0x05, 0x0a,
	0x03, 0x73, 0x75, 0x6d, 0x22, 0xff, 0x06, 0x0a, 0x17, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x34, 0x4c, 0x6f, 0x6e, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67,
	0x12, 0x0c, 0x0a, 0x01, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x01, 0x78, 0x12, 0x24,
	0x0a, 0x01, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74,
	0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
	0x33, 0x52, 0x01, 0x61, 0x12, 0x24, 0x0a, 0x01, 0x62, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x52, 0x01, 0x62, 0x12, 0x24, 0x0a, 0x01, 0x63, 0x18,
	0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61,
	0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x52, 0x01, 0x63,
	0x12, 0x24, 0x0a, 0x01, 0x64, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65,
	0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x33, 0x52, 0x01, 0x64, 0x12, 0x31, 0x0a, 0x01, 0x66, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x21, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73,
	0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x33, 0x4c, 0x6f, 0x6e, 0x65, 0x4e, 0x65, 0x73,
	0x74, 0x69, 0x6e, 0x67, 0x48, 0x00, 0x52, 0x01, 0x66, 0x12, 0x22, 0x0a, 0x01, 0x67, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x41, 0x6e, 0x79, 0x52, 0x01, 0x67, 0x12, 0x24, 0x0a,
	0x01, 0x68, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64,
	0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31,
	0x52, 0x01, 0x68, 0x12, 0x27, 0x0a, 0x01, 0x6b, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13,
	0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d,
	0x65, 0x72, 0x31, 0x42, 0x04, 0xd0, 0xde, 0x1f, 0x01, 0x52, 0x01, 0x6b, 0x12, 0x2d, 0x0a, 0x12,
	0x6e, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x5f, 0x66, 0x69, 0x65,
	0x6c, 0x64, 0x18, 0x87, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x6e, 0x6f, 0x6e, 0x43, 0x72,
	0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x12, 0x40, 0x0a, 0x06, 0x69,
	0x6e, 0x6e, 0x65, 0x72, 0x31, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x74, 0x65,
	0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x34, 0x4c, 0x6f, 0x6e, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x2e, 0x49,
	0x6e, 0x6e, 0x65, 0x72, 0x31, 0x52, 0x06, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x31, 0x12, 0x40, 0x0a,
	0x06, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x32, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e,
	0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x34, 0x4c, 0x6f, 0x6e, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67,
	0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x32, 0x52, 0x06, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x32, 0x1a,
	0xa9, 0x01, 0x0a, 0x06, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x31, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61,
	0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x49,
	0x0a, 0x05, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e,
	0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x34, 0x4c, 0x6f, 0x6e, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67,
	0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x31, 0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x6e,
	0x65, 0x72, 0x52, 0x05, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x1a, 0x30, 0x0a, 0x0a, 0x49, 0x6e, 0x6e,
	0x65, 0x72, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x69, 0x74, 0x79, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x69, 0x74, 0x79, 0x1a, 0xb1, 0x01, 0x0a, 0x06,
	0x49, 0x6e, 0x6e, 0x65, 0x72, 0x32, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72,
	0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79,
	0x12, 0x49, 0x0a, 0x05, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x33, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x34, 0x4c, 0x6f, 0x6e, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x69,
	0x6e, 0x67, 0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x32, 0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x49,
	0x6e, 0x6e, 0x65, 0x72, 0x52, 0x05, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x1a, 0x32, 0x0a, 0x0a, 0x49,
	0x6e, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x42,
	0x05, 0x0a, 0x03, 0x73, 0x75, 0x6d, 0x22, 0xcd, 0x01, 0x0a, 0x0e, 0x54, 0x65, 0x73, 0x74, 0x56,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x46, 0x44, 0x31, 0x12, 0x0c, 0x0a, 0x01, 0x78, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x01, 0x78, 0x12, 0x24, 0x0a, 0x01, 0x61, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65,
	0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31, 0x52, 0x01, 0x61, 0x12, 0x0e, 0x0a,
	0x01, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x01, 0x65, 0x12, 0x26, 0x0a,
	0x01, 0x66, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64,
	0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31,
	0x48, 0x00, 0x52, 0x01, 0x66, 0x12, 0x22, 0x0a, 0x01, 0x67, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x41, 0x6e, 0x79, 0x52, 0x01, 0x67, 0x12, 0x24, 0x0a, 0x01, 0x68, 0x18, 0x09,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e,
	0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31, 0x52, 0x01, 0x68, 0x42,
	0x05, 0x0a, 0x03, 0x73, 0x75, 0x6d, 0x22, 0xdb, 0x01, 0x0a, 0x1a, 0x54, 0x65, 0x73, 0x74, 0x56,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x46, 0x44, 0x31, 0x57, 0x69, 0x74, 0x68, 0x45, 0x78, 0x74,
	0x72, 0x61, 0x41, 0x6e, 0x79, 0x12, 0x0c, 0x0a, 0x01, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03,
	0x52, 0x01, 0x78, 0x12, 0x24, 0x0a, 0x01, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
	0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x56, 0x65,
	0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31, 0x52, 0x01, 0x61, 0x12, 0x0e, 0x0a, 0x01, 0x65, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x01, 0x65, 0x12, 0x26, 0x0a, 0x01, 0x66, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e,
	0x54, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31, 0x48, 0x00, 0x52, 0x01,
	0x66, 0x12, 0x24, 0x0a, 0x01, 0x67, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74,
	0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x41, 0x6e, 0x79, 0x57, 0x69, 0x74, 0x68, 0x45,
	0x78, 0x74, 0x72, 0x61, 0x52, 0x01, 0x67, 0x12, 0x24, 0x0a, 0x01, 0x68, 0x18, 0x09, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x16, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x65,
	0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x31, 0x52, 0x01, 0x68, 0x42, 0x05, 0x0a,
	0x03, 0x73, 0x75, 0x6d, 0x22, 0x54, 0x0a, 0x0c, 0x41, 0x6e, 0x79, 0x57, 0x69, 0x74, 0x68, 0x45,
	0x78, 0x74, 0x72, 0x61, 0x12, 0x28, 0x0a, 0x01, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
	0x66, 0x2e, 0x41, 0x6e, 0x79, 0x42, 0x04, 0xd0, 0xde, 0x1f, 0x01, 0x52, 0x01, 0x61, 0x12, 0x0c,
	0x0a, 0x01, 0x62, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x01, 0x62, 0x12, 0x0c, 0x0a, 0x01,
	0x63, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x01, 0x63, 0x22, 0xc0, 0x01, 0x0a, 0x10, 0x54,
	0x65, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x54, 0x78, 0x52, 0x61, 0x77, 0x12,
	0x1d, 0x0a, 0x0a, 0x62, 0x6f, 0x64, 0x79, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0c, 0x52, 0x09, 0x62, 0x6f, 0x64, 0x79, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x26,
	0x0a, 0x0f, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x5f, 0x62, 0x79, 0x74, 0x65,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0d, 0x61, 0x75, 0x74, 0x68, 0x49, 0x6e, 0x66,
	0x6f, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x1e, 0x0a, 0x0a, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74,
	0x75, 0x72, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x0a, 0x73, 0x69, 0x67, 0x6e,
	0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x1e, 0x0a, 0x0b, 0x6e, 0x65, 0x77, 0x5f, 0x66, 0x69,
	0x65, 0x6c, 0x64, 0x5f, 0x35, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x6e, 0x65, 0x77,
	0x46, 0x69, 0x65, 0x6c, 0x64, 0x35, 0x12, 0x25, 0x0a, 0x0e, 0x6e, 0x65, 0x77, 0x5f, 0x66, 0x69,
	0x65, 0x6c, 0x64, 0x5f, 0x31, 0x30, 0x32, 0x34, 0x18, 0x80, 0x08, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x0c, 0x6e, 0x65, 0x77, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x30, 0x32, 0x34, 0x22, 0x90, 0x03,
	0x0a, 0x11, 0x54, 0x65, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x54, 0x78, 0x42,
	0x6f, 0x64, 0x79, 0x12, 0x30, 0x0a, 0x08, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x41, 0x6e, 0x79, 0x52, 0x08, 0x6d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x6d, 0x65, 0x6d, 0x6f, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x04, 0x6d, 0x65, 0x6d, 0x6f, 0x12, 0x25, 0x0a, 0x0e, 0x74, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x5f, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x03, 0x52, 0x0d, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74,
	0x12, 0x24, 0x0a, 0x0e, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x6e, 0x65, 0x77, 0x5f, 0x66, 0x69, 0x65,
	0x6c, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0c, 0x73, 0x6f, 0x6d, 0x65, 0x4e, 0x65,
	0x77, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x12, 0x48, 0x0a, 0x21, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x6e,
	0x65, 0x77, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x5f, 0x6e, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x69,
	0x74, 0x69, 0x63, 0x61, 0x6c, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x18, 0x9a, 0x08, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x1c, 0x73, 0x6f, 0x6d, 0x65, 0x4e, 0x65, 0x77, 0x46, 0x69, 0x65, 0x6c, 0x64,
	0x4e, 0x6f, 0x6e, 0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x46, 0x69, 0x65, 0x6c, 0x64,
	0x12, 0x42, 0x0a, 0x11, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x6f, 0x70,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xff, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67,
	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x41,
	0x6e, 0x79, 0x52, 0x10, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x4f, 0x70, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x12, 0x5a, 0x0a, 0x1e, 0x6e, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x69, 0x74,
	0x69, 0x63, 0x61, 0x6c, 0x5f, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x6f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xff, 0x0f, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x41, 0x6e, 0x79, 0x52, 0x1b, 0x6e, 0x6f, 0x6e, 0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c,
	0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x22, 0xc8, 0x01, 0x0a, 0x13, 0x54, 0x65, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64,
	0x41, 0x75, 0x74, 0x68, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x40, 0x0a, 0x0c, 0x73, 0x69, 0x67, 0x6e,
	0x65, 0x72, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d,
	0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x74, 0x78, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74,
	0x61, 0x31, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x0b, 0x73,
	0x69, 0x67, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x73, 0x12, 0x28, 0x0a, 0x03, 0x66, 0x65,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x2e, 0x74, 0x78, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x46, 0x65, 0x65, 0x52,
	0x03, 0x66, 0x65, 0x65, 0x12, 0x1e, 0x0a, 0x0b, 0x6e, 0x65, 0x77, 0x5f, 0x66, 0x69, 0x65, 0x6c,
	0x64, 0x5f, 0x33, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x6e, 0x65, 0x77, 0x46, 0x69,
	0x65, 0x6c, 0x64, 0x33, 0x12, 0x25, 0x0a, 0x0e, 0x6e, 0x65, 0x77, 0x5f, 0x66, 0x69, 0x65, 0x6c,
	0x64, 0x5f, 0x31, 0x30, 0x32, 0x34, 0x18, 0x80, 0x08, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0c, 0x6e,
	0x65, 0x77, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x30, 0x32, 0x34, 0x22, 0x27, 0x0a, 0x11, 0x54,
	0x65, 0x73, 0x74, 0x52, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x55, 0x69, 0x6e, 0x74, 0x73,
	0x12, 0x12, 0x0a, 0x04, 0x6e, 0x75, 0x6d, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x04, 0x52, 0x04,
	0x6e, 0x75, 0x6d, 0x73, 0x42, 0x92, 0x01, 0x0a, 0x0c, 0x63, 0x6f, 0x6d, 0x2e, 0x74, 0x65, 0x73,
	0x74, 0x64, 0x61, 0x74, 0x61, 0x42, 0x12, 0x55, 0x6e, 0x6b, 0x6e, 0x6f, 0x6e, 0x77, 0x6e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x2e, 0x67, 0x69, 0x74,
	0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2d, 0x73, 0x64, 0x6b, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x75, 0x74,
	0x69, 0x6c, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0xa2, 0x02, 0x03, 0x54, 0x58,
	0x58, 0xaa, 0x02, 0x08, 0x54, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0xca, 0x02, 0x08, 0x54,
	0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0xe2, 0x02, 0x14, 0x54, 0x65, 0x73, 0x74, 0x64, 0x61,
	0x74, 0x61, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02,
	0x08, 0x54, 0x65, 0x73, 0x74, 0x64, 0x61, 0x74, 0x61, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x33,
}

var (
	file_unknonwnproto_proto_rawDescOnce sync.Once
	file_unknonwnproto_proto_rawDescData = file_unknonwnproto_proto_rawDesc
)

func file_unknonwnproto_proto_rawDescGZIP() []byte {
	file_unknonwnproto_proto_rawDescOnce.Do(func() {
		file_unknonwnproto_proto_rawDescData = protoimpl.X.CompressGZIP(file_unknonwnproto_proto_rawDescData)
	})
	return file_unknonwnproto_proto_rawDescData
}

var file_unknonwnproto_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_unknonwnproto_proto_msgTypes = make([]protoimpl.MessageInfo, 33)
var file_unknonwnproto_proto_goTypes = []interface{}{
	(Customer2_City)(0),                               // 0: testdata.Customer2.City
	(*Customer1)(nil),                                 // 1: testdata.Customer1
	(*Customer2)(nil),                                 // 2: testdata.Customer2
	(*Nested4A)(nil),                                  // 3: testdata.Nested4A
	(*Nested3A)(nil),                                  // 4: testdata.Nested3A
	(*Nested2A)(nil),                                  // 5: testdata.Nested2A
	(*Nested1A)(nil),                                  // 6: testdata.Nested1A
	(*Nested4B)(nil),                                  // 7: testdata.Nested4B
	(*Nested3B)(nil),                                  // 8: testdata.Nested3B
	(*Nested2B)(nil),                                  // 9: testdata.Nested2B
	(*Nested1B)(nil),                                  // 10: testdata.Nested1B
	(*Customer3)(nil),                                 // 11: testdata.Customer3
	(*TestVersion1)(nil),                              // 12: testdata.TestVersion1
	(*TestVersion2)(nil),                              // 13: testdata.TestVersion2
	(*TestVersion3)(nil),                              // 14: testdata.TestVersion3
	(*TestVersion3LoneOneOfValue)(nil),                // 15: testdata.TestVersion3LoneOneOfValue
	(*TestVersion3LoneNesting)(nil),                   // 16: testdata.TestVersion3LoneNesting
	(*TestVersion4LoneNesting)(nil),                   // 17: testdata.TestVersion4LoneNesting
	(*TestVersionFD1)(nil),                            // 18: testdata.TestVersionFD1
	(*TestVersionFD1WithExtraAny)(nil),                // 19: testdata.TestVersionFD1WithExtraAny
	(*AnyWithExtra)(nil),                              // 20: testdata.AnyWithExtra
	(*TestUpdatedTxRaw)(nil),                          // 21: testdata.TestUpdatedTxRaw
	(*TestUpdatedTxBody)(nil),                         // 22: testdata.TestUpdatedTxBody
	(*TestUpdatedAuthInfo)(nil),                       // 23: testdata.TestUpdatedAuthInfo
	(*TestRepeatedUints)(nil),                         // 24: testdata.TestRepeatedUints
	nil,                                               // 25: testdata.Nested3A.IndexEntry
	(*TestVersion3LoneNesting_Inner1)(nil),            // 26: testdata.TestVersion3LoneNesting.Inner1
	(*TestVersion3LoneNesting_Inner2)(nil),            // 27: testdata.TestVersion3LoneNesting.Inner2
	(*TestVersion3LoneNesting_Inner1_InnerInner)(nil), // 28: testdata.TestVersion3LoneNesting.Inner1.InnerInner
	(*TestVersion3LoneNesting_Inner2_InnerInner)(nil), // 29: testdata.TestVersion3LoneNesting.Inner2.InnerInner
	(*TestVersion4LoneNesting_Inner1)(nil),            // 30: testdata.TestVersion4LoneNesting.Inner1
	(*TestVersion4LoneNesting_Inner2)(nil),            // 31: testdata.TestVersion4LoneNesting.Inner2
	(*TestVersion4LoneNesting_Inner1_InnerInner)(nil), // 32: testdata.TestVersion4LoneNesting.Inner1.InnerInner
	(*TestVersion4LoneNesting_Inner2_InnerInner)(nil), // 33: testdata.TestVersion4LoneNesting.Inner2.InnerInner
	(*anypb.Any)(nil),                                 // 34: google.protobuf.Any
	(*v1beta1.SignerInfo)(nil),                        // 35: cosmos.tx.v1beta1.SignerInfo
	(*v1beta1.Fee)(nil),                               // 36: cosmos.tx.v1beta1.Fee
}
var file_unknonwnproto_proto_depIdxs = []int32{
	0,  // 0: testdata.Customer2.city:type_name -> testdata.Customer2.City
	34, // 1: testdata.Customer2.miscellaneous:type_name -> google.protobuf.Any
	3,  // 2: testdata.Nested3A.a4:type_name -> testdata.Nested4A
	25, // 3: testdata.Nested3A.index:type_name -> testdata.Nested3A.IndexEntry
	4,  // 4: testdata.Nested2A.nested:type_name -> testdata.Nested3A
	5,  // 5: testdata.Nested1A.nested:type_name -> testdata.Nested2A
	7,  // 6: testdata.Nested3B.b4:type_name -> testdata.Nested4B
	8,  // 7: testdata.Nested2B.nested:type_name -> testdata.Nested3B
	9,  // 8: testdata.Nested1B.nested:type_name -> testdata.Nested2B
	1,  // 9: testdata.Customer3.original:type_name -> testdata.Customer1
	12, // 10: testdata.TestVersion1.a:type_name -> testdata.TestVersion1
	12, // 11: testdata.TestVersion1.b:type_name -> testdata.TestVersion1
	12, // 12: testdata.TestVersion1.c:type_name -> testdata.TestVersion1
	12, // 13: testdata.TestVersion1.d:type_name -> testdata.TestVersion1
	12, // 14: testdata.TestVersion1.f:type_name -> testdata.TestVersion1
	34, // 15: testdata.TestVersion1.g:type_name -> google.protobuf.Any
	12, // 16: testdata.TestVersion1.h:type_name -> testdata.TestVersion1
	1,  // 17: testdata.TestVersion1.k:type_name -> testdata.Customer1
	13, // 18: testdata.TestVersion2.a:type_name -> testdata.TestVersion2
	13, // 19: testdata.TestVersion2.b:type_name -> testdata.TestVersion2
	13, // 20: testdata.TestVersion2.c:type_name -> testdata.TestVersion2
	13, // 21: testdata.TestVersion2.d:type_name -> testdata.TestVersion2
	13, // 22: testdata.TestVersion2.f:type_name -> testdata.TestVersion2
	34, // 23: testdata.TestVersion2.g:type_name -> google.protobuf.Any
	12, // 24: testdata.TestVersion2.h:type_name -> testdata.TestVersion1
	1,  // 25: testdata.TestVersion2.k:type_name -> testdata.Customer1
	14, // 26: testdata.TestVersion3.a:type_name -> testdata.TestVersion3
	14, // 27: testdata.TestVersion3.b:type_name -> testdata.TestVersion3
	14, // 28: testdata.TestVersion3.c:type_name -> testdata.TestVersion3
	14, // 29: testdata.TestVersion3.d:type_name -> testdata.TestVersion3
	14, // 30: testdata.TestVersion3.f:type_name -> testdata.TestVersion3
	34, // 31: testdata.TestVersion3.g:type_name -> google.protobuf.Any
	12, // 32: testdata.TestVersion3.h:type_name -> testdata.TestVersion1
	1,  // 33: testdata.TestVersion3.k:type_name -> testdata.Customer1
	14, // 34: testdata.TestVersion3LoneOneOfValue.a:type_name -> testdata.TestVersion3
	14, // 35: testdata.TestVersion3LoneOneOfValue.b:type_name -> testdata.TestVersion3
	14, // 36: testdata.TestVersion3LoneOneOfValue.c:type_name -> testdata.TestVersion3
	14, // 37: testdata.TestVersion3LoneOneOfValue.d:type_name -> testdata.TestVersion3
	34, // 38: testdata.TestVersion3LoneOneOfValue.g:type_name -> google.protobuf.Any
	12, // 39: testdata.TestVersion3LoneOneOfValue.h:type_name -> testdata.TestVersion1
	1,  // 40: testdata.TestVersion3LoneOneOfValue.k:type_name -> testdata.Customer1
	14, // 41: testdata.TestVersion3LoneNesting.a:type_name -> testdata.TestVersion3
	14, // 42: testdata.TestVersion3LoneNesting.b:type_name -> testdata.TestVersion3
	14, // 43: testdata.TestVersion3LoneNesting.c:type_name -> testdata.TestVersion3
	14, // 44: testdata.TestVersion3LoneNesting.d:type_name -> testdata.TestVersion3
	16, // 45: testdata.TestVersion3LoneNesting.f:type_name -> testdata.TestVersion3LoneNesting
	34, // 46: testdata.TestVersion3LoneNesting.g:type_name -> google.protobuf.Any
	12, // 47: testdata.TestVersion3LoneNesting.h:type_name -> testdata.TestVersion1
	1,  // 48: testdata.TestVersion3LoneNesting.k:type_name -> testdata.Customer1
	26, // 49: testdata.TestVersion3LoneNesting.inner1:type_name -> testdata.TestVersion3LoneNesting.Inner1
	27, // 50: testdata.TestVersion3LoneNesting.inner2:type_name -> testdata.TestVersion3LoneNesting.Inner2
	14, // 51: testdata.TestVersion4LoneNesting.a:type_name -> testdata.TestVersion3
	14, // 52: testdata.TestVersion4LoneNesting.b:type_name -> testdata.TestVersion3
	14, // 53: testdata.TestVersion4LoneNesting.c:type_name -> testdata.TestVersion3
	14, // 54: testdata.TestVersion4LoneNesting.d:type_name -> testdata.TestVersion3
	16, // 55: testdata.TestVersion4LoneNesting.f:type_name -> testdata.TestVersion3LoneNesting
	34, // 56: testdata.TestVersion4LoneNesting.g:type_name -> google.protobuf.Any
	12, // 57: testdata.TestVersion4LoneNesting.h:type_name -> testdata.TestVersion1
	1,  // 58: testdata.TestVersion4LoneNesting.k:type_name -> testdata.Customer1
	30, // 59: testdata.TestVersion4LoneNesting.inner1:type_name -> testdata.TestVersion4LoneNesting.Inner1
	31, // 60: testdata.TestVersion4LoneNesting.inner2:type_name -> testdata.TestVersion4LoneNesting.Inner2
	12, // 61: testdata.TestVersionFD1.a:type_name -> testdata.TestVersion1
	12, // 62: testdata.TestVersionFD1.f:type_name -> testdata.TestVersion1
	34, // 63: testdata.TestVersionFD1.g:type_name -> google.protobuf.Any
	12, // 64: testdata.TestVersionFD1.h:type_name -> testdata.TestVersion1
	12, // 65: testdata.TestVersionFD1WithExtraAny.a:type_name -> testdata.TestVersion1
	12, // 66: testdata.TestVersionFD1WithExtraAny.f:type_name -> testdata.TestVersion1
	20, // 67: testdata.TestVersionFD1WithExtraAny.g:type_name -> testdata.AnyWithExtra
	12, // 68: testdata.TestVersionFD1WithExtraAny.h:type_name -> testdata.TestVersion1
	34, // 69: testdata.AnyWithExtra.a:type_name -> google.protobuf.Any
	34, // 70: testdata.TestUpdatedTxBody.messages:type_name -> google.protobuf.Any
	34, // 71: testdata.TestUpdatedTxBody.extension_options:type_name -> google.protobuf.Any
	34, // 72: testdata.TestUpdatedTxBody.non_critical_extension_options:type_name -> google.protobuf.Any
	35, // 73: testdata.TestUpdatedAuthInfo.signer_infos:type_name -> cosmos.tx.v1beta1.SignerInfo
	36, // 74: testdata.TestUpdatedAuthInfo.fee:type_name -> cosmos.tx.v1beta1.Fee
	3,  // 75: testdata.Nested3A.IndexEntry.value:type_name -> testdata.Nested4A
	28, // 76: testdata.TestVersion3LoneNesting.Inner1.inner:type_name -> testdata.TestVersion3LoneNesting.Inner1.InnerInner
	29, // 77: testdata.TestVersion3LoneNesting.Inner2.inner:type_name -> testdata.TestVersion3LoneNesting.Inner2.InnerInner
	32, // 78: testdata.TestVersion4LoneNesting.Inner1.inner:type_name -> testdata.TestVersion4LoneNesting.Inner1.InnerInner
	33, // 79: testdata.TestVersion4LoneNesting.Inner2.inner:type_name -> testdata.TestVersion4LoneNesting.Inner2.InnerInner
	80, // [80:80] is the sub-list for method output_type
	80, // [80:80] is the sub-list for method input_type
	80, // [80:80] is the sub-list for extension type_name
	80, // [80:80] is the sub-list for extension extendee
	0,  // [0:80] is the sub-list for field type_name
}

func init() { file_unknonwnproto_proto_init() }
func file_unknonwnproto_proto_init() {
	if File_unknonwnproto_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_unknonwnproto_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Customer1); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Customer2); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Nested4A); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Nested3A); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Nested2A); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Nested1A); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Nested4B); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Nested3B); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Nested2B); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Nested1B); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Customer3); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion1); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion2); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion3); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion3LoneOneOfValue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion3LoneNesting); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion4LoneNesting); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersionFD1); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersionFD1WithExtraAny); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AnyWithExtra); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestUpdatedTxRaw); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestUpdatedTxBody); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestUpdatedAuthInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestRepeatedUints); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion3LoneNesting_Inner1); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion3LoneNesting_Inner2); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion3LoneNesting_Inner1_InnerInner); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion3LoneNesting_Inner2_InnerInner); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion4LoneNesting_Inner1); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion4LoneNesting_Inner2); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion4LoneNesting_Inner1_InnerInner); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_unknonwnproto_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TestVersion4LoneNesting_Inner2_InnerInner); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_unknonwnproto_proto_msgTypes[10].OneofWrappers = []interface{}{
		(*Customer3_CreditCardNo)(nil),
		(*Customer3_ChequeNo)(nil),
	}
	file_unknonwnproto_proto_msgTypes[11].OneofWrappers = []interface{}{
		(*TestVersion1_E)(nil),
		(*TestVersion1_F)(nil),
	}
	file_unknonwnproto_proto_msgTypes[12].OneofWrappers = []interface{}{
		(*TestVersion2_E)(nil),
		(*TestVersion2_F)(nil),
	}
	file_unknonwnproto_proto_msgTypes[13].OneofWrappers = []interface{}{
		(*TestVersion3_E)(nil),
		(*TestVersion3_F)(nil),
	}
	file_unknonwnproto_proto_msgTypes[14].OneofWrappers = []interface{}{
		(*TestVersion3LoneOneOfValue_E)(nil),
	}
	file_unknonwnproto_proto_msgTypes[15].OneofWrappers = []interface{}{
		(*TestVersion3LoneNesting_F)(nil),
	}
	file_unknonwnproto_proto_msgTypes[16].OneofWrappers = []interface{}{
		(*TestVersion4LoneNesting_F)(nil),
	}
	file_unknonwnproto_proto_msgTypes[17].OneofWrappers = []interface{}{
		(*TestVersionFD1_E)(nil),
		(*TestVersionFD1_F)(nil),
	}
	file_unknonwnproto_proto_msgTypes[18].OneofWrappers = []interface{}{
		(*TestVersionFD1WithExtraAny_E)(nil),
		(*TestVersionFD1WithExtraAny_F)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_unknonwnproto_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   33,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_unknonwnproto_proto_goTypes,
		DependencyIndexes: file_unknonwnproto_proto_depIdxs,
		EnumInfos:         file_unknonwnproto_proto_enumTypes,
		MessageInfos:      file_unknonwnproto_proto_msgTypes,
	}.Build()
	File_unknonwnproto_proto = out.File
	file_unknonwnproto_proto_rawDesc = nil
	file_unknonwnproto_proto_goTypes = nil
	file_unknonwnproto_proto_depIdxs = nil
}
func (m *Customer1) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Customer1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Customer1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Payment) > 0 {
		i -= len(m.Payment)
		copy(dAtA[i:], m.Payment)
		i = encodeVarint(dAtA, i, uint64(len(m.Payment)))
		i--
		dAtA[i] = 0x3a
	}
	if m.SubscriptionFee != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SubscriptionFee))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Customer2) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Customer2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Customer2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Reserved != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Reserved))
		i--
		dAtA[i] = 0x41
		i--
		dAtA[i] = 0xb8
	}
	if m.Miscellaneous != nil {
		if marshalto, ok := interface{}(m.Miscellaneous).(interface {
			MarshalToSizedBuffer([]byte) (int, error)
		}); ok {
			size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.Miscellaneous)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.City != 0 {
		i = encodeVarint(dAtA, i, uint64(m.City))
		i--
		dAtA[i] = 0x30
	}
	if m.Fewer != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Fewer))))
		i--
		dAtA[i] = 0x25
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Industry != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Industry))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Nested4A) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nested4A) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Nested4A) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Nested3A) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nested3A) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Nested3A) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Index) > 0 {
		for k := range m.Index {
			v := m.Index[k]
			baseI := i
			size, err := v.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.A4) > 0 {
		for iNdEx := len(m.A4) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.A4[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Nested2A) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nested2A) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Nested2A) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Nested != nil {
		size, err := m.Nested.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Nested1A) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nested1A) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Nested1A) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Nested != nil {
		size, err := m.Nested.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Nested4B) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nested4B) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Nested4B) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Age != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Age))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Nested3B) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nested3B) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Nested3B) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.B4) > 0 {
		for iNdEx := len(m.B4) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.B4[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Age != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Age))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Nested2B) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nested2B) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Nested2B) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Route) > 0 {
		i -= len(m.Route)
		copy(dAtA[i:], m.Route)
		i = encodeVarint(dAtA, i, uint64(len(m.Route)))
		i--
		dAtA[i] = 0x22
	}
	if m.Nested != nil {
		size, err := m.Nested.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Fee != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Fee))))
		i--
		dAtA[i] = 0x11
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Nested1B) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nested1B) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Nested1B) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Age != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Age))
		i--
		dAtA[i] = 0x18
	}
	if m.Nested != nil {
		size, err := m.Nested.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Customer3) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Customer3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Customer3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Original != nil {
		size, err := m.Original.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x4a
	}
	if vtmsg, ok := m.Payment.(interface {
		MarshalTo([]byte) (int, error)
		Size() int
	}); ok {
		{
			size := vtmsg.Size()
			i -= size
			if _, err := vtmsg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarint(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Surcharge != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Surcharge))))
		i--
		dAtA[i] = 0x25
	}
	if m.Sf != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Sf))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Customer3_CreditCardNo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Customer3_CreditCardNo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CreditCardNo)
	copy(dAtA[i:], m.CreditCardNo)
	i = encodeVarint(dAtA, i, uint64(len(m.CreditCardNo)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *Customer3_ChequeNo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Customer3_ChequeNo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ChequeNo)
	copy(dAtA[i:], m.ChequeNo)
	i = encodeVarint(dAtA, i, uint64(len(m.ChequeNo)))
	i--
	dAtA[i] = 0x42
	return len(dAtA) - i, nil
}
func (m *TestVersion1) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.K != nil {
		size, err := m.K.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x62
	}
	if len(m.H) > 0 {
		for iNdEx := len(m.H) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.H[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.G != nil {
		if marshalto, ok := interface{}(m.G).(interface {
			MarshalToSizedBuffer([]byte) (int, error)
		}); ok {
			size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.G)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x42
	}
	if vtmsg, ok := m.Sum.(interface {
		MarshalTo([]byte) (int, error)
		Size() int
	}); ok {
		{
			size := vtmsg.Size()
			i -= size
			if _, err := vtmsg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.D) > 0 {
		for iNdEx := len(m.D) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.D[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.C) > 0 {
		for iNdEx := len(m.C) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.C[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.B != nil {
		size, err := m.B.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.A != nil {
		size, err := m.A.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.X != 0 {
		i = encodeVarint(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion1_E) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion1_E) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.E))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *TestVersion1_F) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion1_F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.F != nil {
		size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *TestVersion2) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.NewField != 0 {
		i = encodeVarint(dAtA, i, uint64(m.NewField))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.K != nil {
		size, err := m.K.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x62
	}
	if len(m.H) > 0 {
		for iNdEx := len(m.H) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.H[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.G != nil {
		if marshalto, ok := interface{}(m.G).(interface {
			MarshalToSizedBuffer([]byte) (int, error)
		}); ok {
			size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.G)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x42
	}
	if vtmsg, ok := m.Sum.(interface {
		MarshalTo([]byte) (int, error)
		Size() int
	}); ok {
		{
			size := vtmsg.Size()
			i -= size
			if _, err := vtmsg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.D) > 0 {
		for iNdEx := len(m.D) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.D[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.C) > 0 {
		for iNdEx := len(m.C) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.C[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.B != nil {
		size, err := m.B.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.A != nil {
		size, err := m.A.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.X != 0 {
		i = encodeVarint(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion2_E) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion2_E) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.E))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *TestVersion2_F) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion2_F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.F != nil {
		size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *TestVersion3) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.NonCriticalField) > 0 {
		i -= len(m.NonCriticalField)
		copy(dAtA[i:], m.NonCriticalField)
		i = encodeVarint(dAtA, i, uint64(len(m.NonCriticalField)))
		i--
		dAtA[i] = 0x40
		i--
		dAtA[i] = 0xba
	}
	if m.K != nil {
		size, err := m.K.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x62
	}
	if len(m.H) > 0 {
		for iNdEx := len(m.H) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.H[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.G != nil {
		if marshalto, ok := interface{}(m.G).(interface {
			MarshalToSizedBuffer([]byte) (int, error)
		}); ok {
			size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.G)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x42
	}
	if vtmsg, ok := m.Sum.(interface {
		MarshalTo([]byte) (int, error)
		Size() int
	}); ok {
		{
			size := vtmsg.Size()
			i -= size
			if _, err := vtmsg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.D) > 0 {
		for iNdEx := len(m.D) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.D[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.C) > 0 {
		for iNdEx := len(m.C) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.C[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.B != nil {
		size, err := m.B.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.A != nil {
		size, err := m.A.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.X != 0 {
		i = encodeVarint(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion3_E) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion3_E) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.E))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *TestVersion3_F) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion3_F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.F != nil {
		size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *TestVersion3LoneOneOfValue) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion3LoneOneOfValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion3LoneOneOfValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.NonCriticalField) > 0 {
		i -= len(m.NonCriticalField)
		copy(dAtA[i:], m.NonCriticalField)
		i = encodeVarint(dAtA, i, uint64(len(m.NonCriticalField)))
		i--
		dAtA[i] = 0x40
		i--
		dAtA[i] = 0xba
	}
	if m.K != nil {
		size, err := m.K.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x62
	}
	if len(m.H) > 0 {
		for iNdEx := len(m.H) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.H[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.G != nil {
		if marshalto, ok := interface{}(m.G).(interface {
			MarshalToSizedBuffer([]byte) (int, error)
		}); ok {
			size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.G)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x42
	}
	if vtmsg, ok := m.Sum.(interface {
		MarshalTo([]byte) (int, error)
		Size() int
	}); ok {
		{
			size := vtmsg.Size()
			i -= size
			if _, err := vtmsg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.D) > 0 {
		for iNdEx := len(m.D) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.D[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.C) > 0 {
		for iNdEx := len(m.C) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.C[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.B != nil {
		size, err := m.B.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.A != nil {
		size, err := m.A.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.X != 0 {
		i = encodeVarint(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion3LoneOneOfValue_E) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion3LoneOneOfValue_E) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.E))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *TestVersion3LoneNesting_Inner1_InnerInner) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion3LoneNesting_Inner1_InnerInner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion3LoneNesting_Inner1_InnerInner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.City) > 0 {
		i -= len(m.City)
		copy(dAtA[i:], m.City)
		i = encodeVarint(dAtA, i, uint64(len(m.City)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarint(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion3LoneNesting_Inner1) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion3LoneNesting_Inner1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion3LoneNesting_Inner1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Inner != nil {
		size, err := m.Inner.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion3LoneNesting_Inner2_InnerInner) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion3LoneNesting_Inner2_InnerInner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion3LoneNesting_Inner2_InnerInner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.City) > 0 {
		i -= len(m.City)
		copy(dAtA[i:], m.City)
		i = encodeVarint(dAtA, i, uint64(len(m.City)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarint(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion3LoneNesting_Inner2) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion3LoneNesting_Inner2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion3LoneNesting_Inner2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Inner != nil {
		size, err := m.Inner.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Country) > 0 {
		i -= len(m.Country)
		copy(dAtA[i:], m.Country)
		i = encodeVarint(dAtA, i, uint64(len(m.Country)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarint(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion3LoneNesting) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion3LoneNesting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion3LoneNesting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.NonCriticalField) > 0 {
		i -= len(m.NonCriticalField)
		copy(dAtA[i:], m.NonCriticalField)
		i = encodeVarint(dAtA, i, uint64(len(m.NonCriticalField)))
		i--
		dAtA[i] = 0x40
		i--
		dAtA[i] = 0xba
	}
	if m.Inner2 != nil {
		size, err := m.Inner2.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x7a
	}
	if m.Inner1 != nil {
		size, err := m.Inner1.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x72
	}
	if m.K != nil {
		size, err := m.K.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x62
	}
	if len(m.H) > 0 {
		for iNdEx := len(m.H) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.H[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.G != nil {
		if marshalto, ok := interface{}(m.G).(interface {
			MarshalToSizedBuffer([]byte) (int, error)
		}); ok {
			size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.G)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x42
	}
	if vtmsg, ok := m.Sum.(interface {
		MarshalTo([]byte) (int, error)
		Size() int
	}); ok {
		{
			size := vtmsg.Size()
			i -= size
			if _, err := vtmsg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.D) > 0 {
		for iNdEx := len(m.D) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.D[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.C) > 0 {
		for iNdEx := len(m.C) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.C[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.B != nil {
		size, err := m.B.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.A != nil {
		size, err := m.A.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.X != 0 {
		i = encodeVarint(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion3LoneNesting_F) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion3LoneNesting_F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.F != nil {
		size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *TestVersion4LoneNesting_Inner1_InnerInner) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion4LoneNesting_Inner1_InnerInner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion4LoneNesting_Inner1_InnerInner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.City) > 0 {
		i -= len(m.City)
		copy(dAtA[i:], m.City)
		i = encodeVarint(dAtA, i, uint64(len(m.City)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion4LoneNesting_Inner1) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion4LoneNesting_Inner1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion4LoneNesting_Inner1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Inner != nil {
		size, err := m.Inner.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarint(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion4LoneNesting_Inner2_InnerInner) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion4LoneNesting_Inner2_InnerInner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion4LoneNesting_Inner2_InnerInner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Value != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarint(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion4LoneNesting_Inner2) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion4LoneNesting_Inner2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion4LoneNesting_Inner2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Inner != nil {
		size, err := m.Inner.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Country) > 0 {
		i -= len(m.Country)
		copy(dAtA[i:], m.Country)
		i = encodeVarint(dAtA, i, uint64(len(m.Country)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarint(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion4LoneNesting) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersion4LoneNesting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion4LoneNesting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.NonCriticalField) > 0 {
		i -= len(m.NonCriticalField)
		copy(dAtA[i:], m.NonCriticalField)
		i = encodeVarint(dAtA, i, uint64(len(m.NonCriticalField)))
		i--
		dAtA[i] = 0x40
		i--
		dAtA[i] = 0xba
	}
	if m.Inner2 != nil {
		size, err := m.Inner2.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x7a
	}
	if m.Inner1 != nil {
		size, err := m.Inner1.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x72
	}
	if m.K != nil {
		size, err := m.K.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x62
	}
	if len(m.H) > 0 {
		for iNdEx := len(m.H) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.H[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.G != nil {
		if marshalto, ok := interface{}(m.G).(interface {
			MarshalToSizedBuffer([]byte) (int, error)
		}); ok {
			size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.G)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x42
	}
	if vtmsg, ok := m.Sum.(interface {
		MarshalTo([]byte) (int, error)
		Size() int
	}); ok {
		{
			size := vtmsg.Size()
			i -= size
			if _, err := vtmsg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.D) > 0 {
		for iNdEx := len(m.D) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.D[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.C) > 0 {
		for iNdEx := len(m.C) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.C[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.B != nil {
		size, err := m.B.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.A != nil {
		size, err := m.A.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.X != 0 {
		i = encodeVarint(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestVersion4LoneNesting_F) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersion4LoneNesting_F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.F != nil {
		size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *TestVersionFD1) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersionFD1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersionFD1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.H) > 0 {
		for iNdEx := len(m.H) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.H[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.G != nil {
		if marshalto, ok := interface{}(m.G).(interface {
			MarshalToSizedBuffer([]byte) (int, error)
		}); ok {
			size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.G)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x42
	}
	if vtmsg, ok := m.Sum.(interface {
		MarshalTo([]byte) (int, error)
		Size() int
	}); ok {
		{
			size := vtmsg.Size()
			i -= size
			if _, err := vtmsg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.A != nil {
		size, err := m.A.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.X != 0 {
		i = encodeVarint(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestVersionFD1_E) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersionFD1_E) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.E))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *TestVersionFD1_F) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersionFD1_F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.F != nil {
		size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *TestVersionFD1WithExtraAny) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestVersionFD1WithExtraAny) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersionFD1WithExtraAny) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.H) > 0 {
		for iNdEx := len(m.H) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.H[iNdEx].MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.G != nil {
		size, err := m.G.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	}
	if vtmsg, ok := m.Sum.(interface {
		MarshalTo([]byte) (int, error)
		Size() int
	}); ok {
		{
			size := vtmsg.Size()
			i -= size
			if _, err := vtmsg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.A != nil {
		size, err := m.A.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.X != 0 {
		i = encodeVarint(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestVersionFD1WithExtraAny_E) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersionFD1WithExtraAny_E) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.E))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *TestVersionFD1WithExtraAny_F) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestVersionFD1WithExtraAny_F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.F != nil {
		size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *AnyWithExtra) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnyWithExtra) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnyWithExtra) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.C != 0 {
		i = encodeVarint(dAtA, i, uint64(m.C))
		i--
		dAtA[i] = 0x20
	}
	if m.B != 0 {
		i = encodeVarint(dAtA, i, uint64(m.B))
		i--
		dAtA[i] = 0x18
	}
	if m.A != nil {
		if marshalto, ok := interface{}(m.A).(interface {
			MarshalToSizedBuffer([]byte) (int, error)
		}); ok {
			size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.A)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestUpdatedTxRaw) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestUpdatedTxRaw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestUpdatedTxRaw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.NewField_1024) > 0 {
		i -= len(m.NewField_1024)
		copy(dAtA[i:], m.NewField_1024)
		i = encodeVarint(dAtA, i, uint64(len(m.NewField_1024)))
		i--
		dAtA[i] = 0x40
		i--
		dAtA[i] = 0x82
	}
	if len(m.NewField_5) > 0 {
		i -= len(m.NewField_5)
		copy(dAtA[i:], m.NewField_5)
		i = encodeVarint(dAtA, i, uint64(len(m.NewField_5)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signatures[iNdEx])
			copy(dAtA[i:], m.Signatures[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.Signatures[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AuthInfoBytes) > 0 {
		i -= len(m.AuthInfoBytes)
		copy(dAtA[i:], m.AuthInfoBytes)
		i = encodeVarint(dAtA, i, uint64(len(m.AuthInfoBytes)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BodyBytes) > 0 {
		i -= len(m.BodyBytes)
		copy(dAtA[i:], m.BodyBytes)
		i = encodeVarint(dAtA, i, uint64(len(m.BodyBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestUpdatedTxBody) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestUpdatedTxBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestUpdatedTxBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.NonCriticalExtensionOptions) > 0 {
		for iNdEx := len(m.NonCriticalExtensionOptions) - 1; iNdEx >= 0; iNdEx-- {
			if marshalto, ok := interface{}(m.NonCriticalExtensionOptions[iNdEx]).(interface {
				MarshalToSizedBuffer([]byte) (int, error)
			}); ok {
				size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.NonCriticalExtensionOptions[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x7f
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.SomeNewFieldNonCriticalField) > 0 {
		i -= len(m.SomeNewFieldNonCriticalField)
		copy(dAtA[i:], m.SomeNewFieldNonCriticalField)
		i = encodeVarint(dAtA, i, uint64(len(m.SomeNewFieldNonCriticalField)))
		i--
		dAtA[i] = 0x41
		i--
		dAtA[i] = 0xd2
	}
	if len(m.ExtensionOptions) > 0 {
		for iNdEx := len(m.ExtensionOptions) - 1; iNdEx >= 0; iNdEx-- {
			if marshalto, ok := interface{}(m.ExtensionOptions[iNdEx]).(interface {
				MarshalToSizedBuffer([]byte) (int, error)
			}); ok {
				size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.ExtensionOptions[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x3f
			i--
			dAtA[i] = 0xfa
		}
	}
	if m.SomeNewField != 0 {
		i = encodeVarint(dAtA, i, uint64(m.SomeNewField))
		i--
		dAtA[i] = 0x20
	}
	if m.TimeoutHeight != 0 {
		i = encodeVarint(dAtA, i, uint64(m.TimeoutHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarint(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Messages) > 0 {
		for iNdEx := len(m.Messages) - 1; iNdEx >= 0; iNdEx-- {
			if marshalto, ok := interface{}(m.Messages[iNdEx]).(interface {
				MarshalToSizedBuffer([]byte) (int, error)
			}); ok {
				size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.Messages[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TestUpdatedAuthInfo) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestUpdatedAuthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestUpdatedAuthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.NewField_1024) > 0 {
		i -= len(m.NewField_1024)
		copy(dAtA[i:], m.NewField_1024)
		i = encodeVarint(dAtA, i, uint64(len(m.NewField_1024)))
		i--
		dAtA[i] = 0x40
		i--
		dAtA[i] = 0x82
	}
	if len(m.NewField_3) > 0 {
		i -= len(m.NewField_3)
		copy(dAtA[i:], m.NewField_3)
		i = encodeVarint(dAtA, i, uint64(len(m.NewField_3)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Fee != nil {
		if marshalto, ok := interface{}(m.Fee).(interface {
			MarshalToSizedBuffer([]byte) (int, error)
		}); ok {
			size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.Fee)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SignerInfos) > 0 {
		for iNdEx := len(m.SignerInfos) - 1; iNdEx >= 0; iNdEx-- {
			if marshalto, ok := interface{}(m.SignerInfos[iNdEx]).(interface {
				MarshalToSizedBuffer([]byte) (int, error)
			}); ok {
				size, err := marshalto.MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.SignerInfos[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TestRepeatedUints) Marshal() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestRepeatedUints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestRepeatedUints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Nums) > 0 {
		var pksize2 int
		for _, num := range m.Nums {
			pksize2 += sov(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num := range m.Nums {
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = encodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Customer1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.SubscriptionFee != 0 {
		n += 5
	}
	l = len(m.Payment)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *Customer2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	if m.Industry != 0 {
		n += 1 + sov(uint64(m.Industry))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.Fewer != 0 {
		n += 5
	}
	if m.City != 0 {
		n += 1 + sov(uint64(m.City))
	}
	if m.Miscellaneous != nil {
		if size, ok := interface{}(m.Miscellaneous).(interface {
			Size() int
		}); ok {
			l = size.Size()
		} else {
			l = proto.Size(m.Miscellaneous)
		}
		n += 1 + l + sov(uint64(l))
	}
	if m.Reserved != 0 {
		n += 2 + sov(uint64(m.Reserved))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *Nested4A) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *Nested3A) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if len(m.A4) > 0 {
		for _, e := range m.A4 {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.Index) > 0 {
		for k, v := range m.Index {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			l += 1 + sov(uint64(l))
			mapEntrySize := 1 + sov(uint64(k)) + l
			n += mapEntrySize + 1 + sov(uint64(mapEntrySize))
		}
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *Nested2A) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.Nested != nil {
		l = m.Nested.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *Nested1A) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	if m.Nested != nil {
		l = m.Nested.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *Nested4B) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	if m.Age != 0 {
		n += 1 + sov(uint64(m.Age))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *Nested3B) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	if m.Age != 0 {
		n += 1 + sov(uint64(m.Age))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if len(m.B4) > 0 {
		for _, e := range m.B4 {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *Nested2B) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	if m.Fee != 0 {
		n += 9
	}
	if m.Nested != nil {
		l = m.Nested.Size()
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.Route)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *Nested1B) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	if m.Nested != nil {
		l = m.Nested.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.Age != 0 {
		n += 1 + sov(uint64(m.Age))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *Customer3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.Sf != 0 {
		n += 5
	}
	if m.Surcharge != 0 {
		n += 5
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if vtmsg, ok := m.Payment.(interface{ Size() int }); ok {
		n += vtmsg.Size()
	}
	if m.Original != nil {
		l = m.Original.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *Customer3_CreditCardNo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CreditCardNo)
	n += 1 + l + sov(uint64(l))
	return n
}
func (m *Customer3_ChequeNo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChequeNo)
	n += 1 + l + sov(uint64(l))
	return n
}
func (m *TestVersion1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sov(uint64(m.X))
	}
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.B != nil {
		l = m.B.Size()
		n += 1 + l + sov(uint64(l))
	}
	if len(m.C) > 0 {
		for _, e := range m.C {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.D) > 0 {
		for _, e := range m.D {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if vtmsg, ok := m.Sum.(interface{ Size() int }); ok {
		n += vtmsg.Size()
	}
	if m.G != nil {
		if size, ok := interface{}(m.G).(interface {
			Size() int
		}); ok {
			l = size.Size()
		} else {
			l = proto.Size(m.G)
		}
		n += 1 + l + sov(uint64(l))
	}
	if len(m.H) > 0 {
		for _, e := range m.H {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.K != nil {
		l = m.K.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion1_E) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sov(uint64(m.E))
	return n
}
func (m *TestVersion1_F) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != nil {
		l = m.F.Size()
		n += 1 + l + sov(uint64(l))
	}
	return n
}
func (m *TestVersion2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sov(uint64(m.X))
	}
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.B != nil {
		l = m.B.Size()
		n += 1 + l + sov(uint64(l))
	}
	if len(m.C) > 0 {
		for _, e := range m.C {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.D) > 0 {
		for _, e := range m.D {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if vtmsg, ok := m.Sum.(interface{ Size() int }); ok {
		n += vtmsg.Size()
	}
	if m.G != nil {
		if size, ok := interface{}(m.G).(interface {
			Size() int
		}); ok {
			l = size.Size()
		} else {
			l = proto.Size(m.G)
		}
		n += 1 + l + sov(uint64(l))
	}
	if len(m.H) > 0 {
		for _, e := range m.H {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.K != nil {
		l = m.K.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.NewField != 0 {
		n += 2 + sov(uint64(m.NewField))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion2_E) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sov(uint64(m.E))
	return n
}
func (m *TestVersion2_F) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != nil {
		l = m.F.Size()
		n += 1 + l + sov(uint64(l))
	}
	return n
}
func (m *TestVersion3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sov(uint64(m.X))
	}
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.B != nil {
		l = m.B.Size()
		n += 1 + l + sov(uint64(l))
	}
	if len(m.C) > 0 {
		for _, e := range m.C {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.D) > 0 {
		for _, e := range m.D {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if vtmsg, ok := m.Sum.(interface{ Size() int }); ok {
		n += vtmsg.Size()
	}
	if m.G != nil {
		if size, ok := interface{}(m.G).(interface {
			Size() int
		}); ok {
			l = size.Size()
		} else {
			l = proto.Size(m.G)
		}
		n += 1 + l + sov(uint64(l))
	}
	if len(m.H) > 0 {
		for _, e := range m.H {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.K != nil {
		l = m.K.Size()
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.NonCriticalField)
	if l > 0 {
		n += 2 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion3_E) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sov(uint64(m.E))
	return n
}
func (m *TestVersion3_F) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != nil {
		l = m.F.Size()
		n += 1 + l + sov(uint64(l))
	}
	return n
}
func (m *TestVersion3LoneOneOfValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sov(uint64(m.X))
	}
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.B != nil {
		l = m.B.Size()
		n += 1 + l + sov(uint64(l))
	}
	if len(m.C) > 0 {
		for _, e := range m.C {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.D) > 0 {
		for _, e := range m.D {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if vtmsg, ok := m.Sum.(interface{ Size() int }); ok {
		n += vtmsg.Size()
	}
	if m.G != nil {
		if size, ok := interface{}(m.G).(interface {
			Size() int
		}); ok {
			l = size.Size()
		} else {
			l = proto.Size(m.G)
		}
		n += 1 + l + sov(uint64(l))
	}
	if len(m.H) > 0 {
		for _, e := range m.H {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.K != nil {
		l = m.K.Size()
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.NonCriticalField)
	if l > 0 {
		n += 2 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion3LoneOneOfValue_E) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sov(uint64(m.E))
	return n
}
func (m *TestVersion3LoneNesting_Inner1_InnerInner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion3LoneNesting_Inner1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.Inner != nil {
		l = m.Inner.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion3LoneNesting_Inner2_InnerInner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion3LoneNesting_Inner2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.Inner != nil {
		l = m.Inner.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion3LoneNesting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sov(uint64(m.X))
	}
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.B != nil {
		l = m.B.Size()
		n += 1 + l + sov(uint64(l))
	}
	if len(m.C) > 0 {
		for _, e := range m.C {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.D) > 0 {
		for _, e := range m.D {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if vtmsg, ok := m.Sum.(interface{ Size() int }); ok {
		n += vtmsg.Size()
	}
	if m.G != nil {
		if size, ok := interface{}(m.G).(interface {
			Size() int
		}); ok {
			l = size.Size()
		} else {
			l = proto.Size(m.G)
		}
		n += 1 + l + sov(uint64(l))
	}
	if len(m.H) > 0 {
		for _, e := range m.H {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.K != nil {
		l = m.K.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.Inner1 != nil {
		l = m.Inner1.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.Inner2 != nil {
		l = m.Inner2.Size()
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.NonCriticalField)
	if l > 0 {
		n += 2 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion3LoneNesting_F) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != nil {
		l = m.F.Size()
		n += 1 + l + sov(uint64(l))
	}
	return n
}
func (m *TestVersion4LoneNesting_Inner1_InnerInner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion4LoneNesting_Inner1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.Inner != nil {
		l = m.Inner.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion4LoneNesting_Inner2_InnerInner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sov(uint64(m.Value))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion4LoneNesting_Inner2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.Inner != nil {
		l = m.Inner.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion4LoneNesting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sov(uint64(m.X))
	}
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.B != nil {
		l = m.B.Size()
		n += 1 + l + sov(uint64(l))
	}
	if len(m.C) > 0 {
		for _, e := range m.C {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.D) > 0 {
		for _, e := range m.D {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if vtmsg, ok := m.Sum.(interface{ Size() int }); ok {
		n += vtmsg.Size()
	}
	if m.G != nil {
		if size, ok := interface{}(m.G).(interface {
			Size() int
		}); ok {
			l = size.Size()
		} else {
			l = proto.Size(m.G)
		}
		n += 1 + l + sov(uint64(l))
	}
	if len(m.H) > 0 {
		for _, e := range m.H {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.K != nil {
		l = m.K.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.Inner1 != nil {
		l = m.Inner1.Size()
		n += 1 + l + sov(uint64(l))
	}
	if m.Inner2 != nil {
		l = m.Inner2.Size()
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.NonCriticalField)
	if l > 0 {
		n += 2 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersion4LoneNesting_F) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != nil {
		l = m.F.Size()
		n += 1 + l + sov(uint64(l))
	}
	return n
}
func (m *TestVersionFD1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sov(uint64(m.X))
	}
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sov(uint64(l))
	}
	if vtmsg, ok := m.Sum.(interface{ Size() int }); ok {
		n += vtmsg.Size()
	}
	if m.G != nil {
		if size, ok := interface{}(m.G).(interface {
			Size() int
		}); ok {
			l = size.Size()
		} else {
			l = proto.Size(m.G)
		}
		n += 1 + l + sov(uint64(l))
	}
	if len(m.H) > 0 {
		for _, e := range m.H {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersionFD1_E) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sov(uint64(m.E))
	return n
}
func (m *TestVersionFD1_F) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != nil {
		l = m.F.Size()
		n += 1 + l + sov(uint64(l))
	}
	return n
}
func (m *TestVersionFD1WithExtraAny) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sov(uint64(m.X))
	}
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sov(uint64(l))
	}
	if vtmsg, ok := m.Sum.(interface{ Size() int }); ok {
		n += vtmsg.Size()
	}
	if m.G != nil {
		l = m.G.Size()
		n += 1 + l + sov(uint64(l))
	}
	if len(m.H) > 0 {
		for _, e := range m.H {
			l = e.Size()
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestVersionFD1WithExtraAny_E) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sov(uint64(m.E))
	return n
}
func (m *TestVersionFD1WithExtraAny_F) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != nil {
		l = m.F.Size()
		n += 1 + l + sov(uint64(l))
	}
	return n
}
func (m *AnyWithExtra) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != nil {
		if size, ok := interface{}(m.A).(interface {
			Size() int
		}); ok {
			l = size.Size()
		} else {
			l = proto.Size(m.A)
		}
		n += 1 + l + sov(uint64(l))
	}
	if m.B != 0 {
		n += 1 + sov(uint64(m.B))
	}
	if m.C != 0 {
		n += 1 + sov(uint64(m.C))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestUpdatedTxRaw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BodyBytes)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.AuthInfoBytes)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, b := range m.Signatures {
			l = len(b)
			n += 1 + l + sov(uint64(l))
		}
	}
	l = len(m.NewField_5)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.NewField_1024)
	if l > 0 {
		n += 2 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestUpdatedTxBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			if size, ok := interface{}(e).(interface {
				Size() int
			}); ok {
				l = size.Size()
			} else {
				l = proto.Size(e)
			}
			n += 1 + l + sov(uint64(l))
		}
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.TimeoutHeight != 0 {
		n += 1 + sov(uint64(m.TimeoutHeight))
	}
	if m.SomeNewField != 0 {
		n += 1 + sov(uint64(m.SomeNewField))
	}
	if len(m.ExtensionOptions) > 0 {
		for _, e := range m.ExtensionOptions {
			if size, ok := interface{}(e).(interface {
				Size() int
			}); ok {
				l = size.Size()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	l = len(m.SomeNewFieldNonCriticalField)
	if l > 0 {
		n += 2 + l + sov(uint64(l))
	}
	if len(m.NonCriticalExtensionOptions) > 0 {
		for _, e := range m.NonCriticalExtensionOptions {
			if size, ok := interface{}(e).(interface {
				Size() int
			}); ok {
				l = size.Size()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestUpdatedAuthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SignerInfos) > 0 {
		for _, e := range m.SignerInfos {
			if size, ok := interface{}(e).(interface {
				Size() int
			}); ok {
				l = size.Size()
			} else {
				l = proto.Size(e)
			}
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.Fee != nil {
		if size, ok := interface{}(m.Fee).(interface {
			Size() int
		}); ok {
			l = size.Size()
		} else {
			l = proto.Size(m.Fee)
		}
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.NewField_3)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.NewField_1024)
	if l > 0 {
		n += 2 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestRepeatedUints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nums) > 0 {
		l = 0
		for _, e := range m.Nums {
			l += sov(uint64(e))
		}
		n += 1 + sov(uint64(l)) + l
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *Customer1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Customer1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Customer1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionFee", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SubscriptionFee = float32(math.Float32frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Customer2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Customer2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Customer2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Industry", wireType)
			}
			m.Industry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Industry |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fewer", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Fewer = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			m.City = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.City |= Customer2_City(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miscellaneous", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Miscellaneous == nil {
				m.Miscellaneous = &anypb.Any{}
			}
			if unmarshal, ok := interface{}(m.Miscellaneous).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Miscellaneous); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 1047:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			m.Reserved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nested4A) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested4A: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested4A: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nested3A) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested3A: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested3A: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A4 = append(m.A4, &Nested4A{})
			if err := m.A4[len(m.A4)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Index == nil {
				m.Index = make(map[int64]*Nested4A)
			}
			var mapkey int64
			var mapvalue *Nested4A
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Nested4A{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Index[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nested2A) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested2A: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested2A: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nested == nil {
				m.Nested = &Nested3A{}
			}
			if err := m.Nested.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nested1A) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested1A: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested1A: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nested == nil {
				m.Nested = &Nested2A{}
			}
			if err := m.Nested.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nested4B) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested4B: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested4B: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Age", wireType)
			}
			m.Age = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Age |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nested3B) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested3B: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested3B: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Age", wireType)
			}
			m.Age = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Age |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.B4 = append(m.B4, &Nested4B{})
			if err := m.B4[len(m.B4)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nested2B) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested2B: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested2B: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Fee = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nested == nil {
				m.Nested = &Nested3B{}
			}
			if err := m.Nested.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Route = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nested1B) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested1B: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested1B: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nested == nil {
				m.Nested = &Nested2B{}
			}
			if err := m.Nested.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Age", wireType)
			}
			m.Age = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Age |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Customer3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Customer3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Customer3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sf", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Sf = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Surcharge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Surcharge = float32(math.Float32frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditCardNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payment = &Customer3_CreditCardNo{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChequeNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payment = &Customer3_ChequeNo{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Original", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Original == nil {
				m.Original = &Customer1{}
			}
			if err := m.Original.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &TestVersion1{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.B == nil {
				m.B = &TestVersion1{}
			}
			if err := m.B.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.C = append(m.C, &TestVersion1{})
			if err := m.C[len(m.C)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.D = append(m.D, &TestVersion1{})
			if err := m.D[len(m.D)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sum = &TestVersion1_E{v}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Sum.(*TestVersion1_F); ok {
				if err := oneof.F.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TestVersion1{}
				if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Sum = &TestVersion1_F{v}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.G == nil {
				m.G = &anypb.Any{}
			}
			if unmarshal, ok := interface{}(m.G).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.G); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.H = append(m.H, &TestVersion1{})
			if err := m.H[len(m.H)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K == nil {
				m.K = &Customer1{}
			}
			if err := m.K.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &TestVersion2{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.B == nil {
				m.B = &TestVersion2{}
			}
			if err := m.B.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.C = append(m.C, &TestVersion2{})
			if err := m.C[len(m.C)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.D = append(m.D, &TestVersion2{})
			if err := m.D[len(m.D)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sum = &TestVersion2_E{v}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Sum.(*TestVersion2_F); ok {
				if err := oneof.F.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TestVersion2{}
				if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Sum = &TestVersion2_F{v}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.G == nil {
				m.G = &anypb.Any{}
			}
			if unmarshal, ok := interface{}(m.G).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.G); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.H = append(m.H, &TestVersion1{})
			if err := m.H[len(m.H)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K == nil {
				m.K = &Customer1{}
			}
			if err := m.K.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewField", wireType)
			}
			m.NewField = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewField |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &TestVersion3{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.B == nil {
				m.B = &TestVersion3{}
			}
			if err := m.B.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.C = append(m.C, &TestVersion3{})
			if err := m.C[len(m.C)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.D = append(m.D, &TestVersion3{})
			if err := m.D[len(m.D)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sum = &TestVersion3_E{v}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Sum.(*TestVersion3_F); ok {
				if err := oneof.F.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TestVersion3{}
				if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Sum = &TestVersion3_F{v}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.G == nil {
				m.G = &anypb.Any{}
			}
			if unmarshal, ok := interface{}(m.G).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.G); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.H = append(m.H, &TestVersion1{})
			if err := m.H[len(m.H)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K == nil {
				m.K = &Customer1{}
			}
			if err := m.K.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1031:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonCriticalField", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonCriticalField = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion3LoneOneOfValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion3LoneOneOfValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion3LoneOneOfValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &TestVersion3{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.B == nil {
				m.B = &TestVersion3{}
			}
			if err := m.B.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.C = append(m.C, &TestVersion3{})
			if err := m.C[len(m.C)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.D = append(m.D, &TestVersion3{})
			if err := m.D[len(m.D)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sum = &TestVersion3LoneOneOfValue_E{v}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.G == nil {
				m.G = &anypb.Any{}
			}
			if unmarshal, ok := interface{}(m.G).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.G); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.H = append(m.H, &TestVersion1{})
			if err := m.H[len(m.H)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K == nil {
				m.K = &Customer1{}
			}
			if err := m.K.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1031:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonCriticalField", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonCriticalField = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion3LoneNesting_Inner1_InnerInner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion3LoneNesting_Inner1_InnerInner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion3LoneNesting_Inner1_InnerInner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion3LoneNesting_Inner1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion3LoneNesting_Inner1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion3LoneNesting_Inner1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner == nil {
				m.Inner = &TestVersion3LoneNesting_Inner1_InnerInner{}
			}
			if err := m.Inner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion3LoneNesting_Inner2_InnerInner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion3LoneNesting_Inner2_InnerInner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion3LoneNesting_Inner2_InnerInner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion3LoneNesting_Inner2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion3LoneNesting_Inner2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion3LoneNesting_Inner2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner == nil {
				m.Inner = &TestVersion3LoneNesting_Inner2_InnerInner{}
			}
			if err := m.Inner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion3LoneNesting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion3LoneNesting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion3LoneNesting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &TestVersion3{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.B == nil {
				m.B = &TestVersion3{}
			}
			if err := m.B.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.C = append(m.C, &TestVersion3{})
			if err := m.C[len(m.C)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.D = append(m.D, &TestVersion3{})
			if err := m.D[len(m.D)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Sum.(*TestVersion3LoneNesting_F); ok {
				if err := oneof.F.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TestVersion3LoneNesting{}
				if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Sum = &TestVersion3LoneNesting_F{v}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.G == nil {
				m.G = &anypb.Any{}
			}
			if unmarshal, ok := interface{}(m.G).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.G); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.H = append(m.H, &TestVersion1{})
			if err := m.H[len(m.H)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K == nil {
				m.K = &Customer1{}
			}
			if err := m.K.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner1 == nil {
				m.Inner1 = &TestVersion3LoneNesting_Inner1{}
			}
			if err := m.Inner1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner2 == nil {
				m.Inner2 = &TestVersion3LoneNesting_Inner2{}
			}
			if err := m.Inner2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1031:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonCriticalField", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonCriticalField = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion4LoneNesting_Inner1_InnerInner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion4LoneNesting_Inner1_InnerInner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion4LoneNesting_Inner1_InnerInner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion4LoneNesting_Inner1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion4LoneNesting_Inner1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion4LoneNesting_Inner1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner == nil {
				m.Inner = &TestVersion4LoneNesting_Inner1_InnerInner{}
			}
			if err := m.Inner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion4LoneNesting_Inner2_InnerInner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion4LoneNesting_Inner2_InnerInner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion4LoneNesting_Inner2_InnerInner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion4LoneNesting_Inner2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion4LoneNesting_Inner2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion4LoneNesting_Inner2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner == nil {
				m.Inner = &TestVersion4LoneNesting_Inner2_InnerInner{}
			}
			if err := m.Inner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersion4LoneNesting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersion4LoneNesting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersion4LoneNesting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &TestVersion3{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.B == nil {
				m.B = &TestVersion3{}
			}
			if err := m.B.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.C = append(m.C, &TestVersion3{})
			if err := m.C[len(m.C)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.D = append(m.D, &TestVersion3{})
			if err := m.D[len(m.D)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Sum.(*TestVersion4LoneNesting_F); ok {
				if err := oneof.F.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TestVersion3LoneNesting{}
				if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Sum = &TestVersion4LoneNesting_F{v}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.G == nil {
				m.G = &anypb.Any{}
			}
			if unmarshal, ok := interface{}(m.G).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.G); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.H = append(m.H, &TestVersion1{})
			if err := m.H[len(m.H)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K == nil {
				m.K = &Customer1{}
			}
			if err := m.K.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner1 == nil {
				m.Inner1 = &TestVersion4LoneNesting_Inner1{}
			}
			if err := m.Inner1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner2 == nil {
				m.Inner2 = &TestVersion4LoneNesting_Inner2{}
			}
			if err := m.Inner2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1031:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonCriticalField", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonCriticalField = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersionFD1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersionFD1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersionFD1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &TestVersion1{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sum = &TestVersionFD1_E{v}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Sum.(*TestVersionFD1_F); ok {
				if err := oneof.F.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TestVersion1{}
				if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Sum = &TestVersionFD1_F{v}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.G == nil {
				m.G = &anypb.Any{}
			}
			if unmarshal, ok := interface{}(m.G).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.G); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.H = append(m.H, &TestVersion1{})
			if err := m.H[len(m.H)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestVersionFD1WithExtraAny) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestVersionFD1WithExtraAny: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestVersionFD1WithExtraAny: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &TestVersion1{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sum = &TestVersionFD1WithExtraAny_E{v}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Sum.(*TestVersionFD1WithExtraAny_F); ok {
				if err := oneof.F.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TestVersion1{}
				if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Sum = &TestVersionFD1WithExtraAny_F{v}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.G == nil {
				m.G = &AnyWithExtra{}
			}
			if err := m.G.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.H = append(m.H, &TestVersion1{})
			if err := m.H[len(m.H)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnyWithExtra) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyWithExtra: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyWithExtra: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &anypb.Any{}
			}
			if unmarshal, ok := interface{}(m.A).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.A); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			m.B = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.B |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			m.C = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.C |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestUpdatedTxRaw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestUpdatedTxRaw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestUpdatedTxRaw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyBytes = append(m.BodyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.BodyBytes == nil {
				m.BodyBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthInfoBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthInfoBytes = append(m.AuthInfoBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthInfoBytes == nil {
				m.AuthInfoBytes = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, make([]byte, postIndex-iNdEx))
			copy(m.Signatures[len(m.Signatures)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewField_5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewField_5 = append(m.NewField_5[:0], dAtA[iNdEx:postIndex]...)
			if m.NewField_5 == nil {
				m.NewField_5 = []byte{}
			}
			iNdEx = postIndex
		case 1024:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewField_1024", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewField_1024 = append(m.NewField_1024[:0], dAtA[iNdEx:postIndex]...)
			if m.NewField_1024 == nil {
				m.NewField_1024 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestUpdatedTxBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestUpdatedTxBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestUpdatedTxBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &anypb.Any{})
			if unmarshal, ok := interface{}(m.Messages[len(m.Messages)-1]).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Messages[len(m.Messages)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutHeight", wireType)
			}
			m.TimeoutHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SomeNewField", wireType)
			}
			m.SomeNewField = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SomeNewField |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1023:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtensionOptions = append(m.ExtensionOptions, &anypb.Any{})
			if unmarshal, ok := interface{}(m.ExtensionOptions[len(m.ExtensionOptions)-1]).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.ExtensionOptions[len(m.ExtensionOptions)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 1050:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SomeNewFieldNonCriticalField", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SomeNewFieldNonCriticalField = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2047:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonCriticalExtensionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonCriticalExtensionOptions = append(m.NonCriticalExtensionOptions, &anypb.Any{})
			if unmarshal, ok := interface{}(m.NonCriticalExtensionOptions[len(m.NonCriticalExtensionOptions)-1]).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.NonCriticalExtensionOptions[len(m.NonCriticalExtensionOptions)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestUpdatedAuthInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestUpdatedAuthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestUpdatedAuthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignerInfos = append(m.SignerInfos, &v1beta1.SignerInfo{})
			if unmarshal, ok := interface{}(m.SignerInfos[len(m.SignerInfos)-1]).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.SignerInfos[len(m.SignerInfos)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &v1beta1.Fee{}
			}
			if unmarshal, ok := interface{}(m.Fee).(interface {
				Unmarshal([]byte) error
			}); ok {
				if err := unmarshal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Fee); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewField_3", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewField_3 = append(m.NewField_3[:0], dAtA[iNdEx:postIndex]...)
			if m.NewField_3 == nil {
				m.NewField_3 = []byte{}
			}
			iNdEx = postIndex
		case 1024:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewField_1024", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewField_1024 = append(m.NewField_1024[:0], dAtA[iNdEx:postIndex]...)
			if m.NewField_1024 == nil {
				m.NewField_1024 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestRepeatedUints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestRepeatedUints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestRepeatedUints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nums = append(m.Nums, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Nums) == 0 {
					m.Nums = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nums = append(m.Nums, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nums", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
